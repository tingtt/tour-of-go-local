{"flowcontrol":{"Title":"Flow control statements: for, if, else, switch and defer","Description":"条件文とループ、switch、defer を使ってコードの流れをコントロールする方法を学びます。","Pages":[{"Title":"For","Content":"\n  \u003ch2\u003eFor\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    基本的に、 \u003ccode\u003efor\u003c/code\u003e ループはセミコロン \u003ccode\u003e;\u003c/code\u003e で3つの部分に分かれています:\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e初期化ステートメント: 最初のイテレーション(繰り返し)の前に初期化が実行されます\u003c/li\u003e\n  \n    \u003cli\u003e条件式: イテレーション毎に評価されます\u003c/li\u003e\n  \n    \u003cli\u003e後処理ステートメント: イテレーション毎の最後に実行されます\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    初期化ステートメントは、短い変数宣言によく利用します。その変数は \u003ccode\u003efor\u003c/code\u003e ステートメントのスコープ内でのみ有効です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ループは、条件式の評価が \u003ccode\u003efalse\u003c/code\u003e となった場合にイテレーションを停止します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ci\u003eNote\u003c/i\u003e: 他の言語、C言語 や Java、JavaScriptの \u003ccode\u003efor\u003c/code\u003e ループとは異なり、 \u003ccode\u003efor\u003c/code\u003e ステートメントの3つの部分を括る括弧 \u003ccode\u003e( )\u003c/code\u003e はありません。なお、中括弧 \u003ccode\u003e{ }\u003c/code\u003e は常に必要です。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"for.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i \u003c 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n","Hash":"xJO/6+FEIQikuVbnofxw9o7g3Ig="}]},{"Title":"For continued","Content":"\n  \u003ch2\u003eFor continued\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    初期化と後処理ステートメントの記述は任意です。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"for-continued.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 1\n\tfor ; sum \u003c 1000; {\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n","Hash":"1SQ3UcrOPXhbZIL80CcWqOUSGP4="}]},{"Title":"For is Go's \"while\"","Content":"\n  \u003ch2\u003eFor is Go\u0026#39;s \u0026#34;while\u0026#34;\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    セミコロン(;)を省略することもできます。つまり、C言語などにある \u003ccode\u003ewhile\u003c/code\u003e は、Goでは \u003ccode\u003efor\u003c/code\u003e だけを使います。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"for-is-gos-while.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 1\n\tfor sum \u003c 1000 {\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n","Hash":"0C6Q8vy+sOTo5FmeCSn0gOHKfis="}]},{"Title":"Forever","Content":"\n  \u003ch2\u003eForever\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    ループ条件を省略すれば、無限ループ( \u003ci\u003einfinite loop\u003c/i\u003e )になりますので、無限ループをコンパクトに表現できます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"forever.go","Content":"package main\n\nfunc main() {\n\tfor {\n\t}\n}\n","Hash":"LGPmerQM9dL5ipTYobVqMxgS2zc="}]},{"Title":"If","Content":"\n  \u003ch2\u003eIf\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go言語の \u003ccode\u003eif\u003c/code\u003e ステートメントは、先ほどの \u003ccode\u003efor\u003c/code\u003e ループと同様に、括弧 \u003ccode\u003e( )\u003c/code\u003e は不要で、中括弧 \u003ccode\u003e{ }\u003c/code\u003e は必要です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (もうおなじみですね！)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"if.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc sqrt(x float64) string {\n\tif x \u003c 0 {\n\t\treturn sqrt(-x) + \"i\"\n\t}\n\treturn fmt.Sprint(math.Sqrt(x))\n}\n\nfunc main() {\n\tfmt.Println(sqrt(2), sqrt(-4))\n}\n","Hash":"r6fhyVTMogkJiLiZwAdhwGl+kZM="}]},{"Title":"If with a short statement","Content":"\n  \u003ch2\u003eIf with a short statement\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eif\u003c/code\u003e ステートメントは、 \u003ccode\u003efor\u003c/code\u003e のように、条件の前に、評価するための簡単なステートメントを書くことができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ここで宣言された変数は、 \u003ccode\u003eif\u003c/code\u003e のスコープ内だけで有効です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (ためしに最後の \u003ccode\u003ereturn\u003c/code\u003e 文で、 \u003ccode\u003ev\u003c/code\u003e を使ってみてください。\n\n\n    スコープの外なので使えないですよね？)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"if-with-a-short-statement.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v \u003c lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n","Hash":"Qdj1mMXhmi0bxex0sdU6BzhPM+g="}]},{"Title":"If and else","Content":"\n  \u003ch2\u003eIf and else\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    なお、 \u003ccode\u003eif\u003c/code\u003e ステートメントで宣言された変数は、 \u003ccode\u003eelse\u003c/code\u003e ブロック内でも使うことができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (コードの補足: \u003ccode\u003emain\u003c/code\u003e の \u003ccode\u003efmt.Println\u003c/code\u003e は、2つの \u003ccode\u003epow\u003c/code\u003e が先に実行されてから実行されます)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"if-and-else.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v \u003c lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g \u003e= %g\\n\", v, lim)\n\t}\n\t// can't use v here, though\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n","Hash":"QFGZZx7YHQyh1OOVlVLgXw7u0nY="}]},{"Title":"Exercise: Loops and Functions","Content":"\n  \u003ch2\u003eExercise: Loops and Functions\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数とループを使った簡単な練習として、平方根の計算を実装してみましょう: 数値 x が与えられたときに z² が最も x に近い数値 z を求めたいと思います。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    コンピュータは通常ループを使って x の平方根を計算します。\n\n\n    いくつかの z を推測することから始めて、z² がどれほど x に近づいているかに応じて z を調整できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ez -= (z*z - x) / (2*z)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    実際の平方根に近い答えになるまでこの調整を繰り返すことによって、推測はより良いものなります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    これを \u003ccode\u003efunc Sqrt\u003c/code\u003e に実装してください。\n\n\n    何が入力されても z の適切な開始推測値は 1 です。\n\n\n    まず計算を 10 回繰り返してそれぞれの z を表示します。\n\n\n    x (1, 2, 3, ...) のさまざまな値に対する答えがどれほど近似し、\n\n\n    推測が速くなるかを確認してください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Hint: 浮動小数点の変数を初期化して宣言するには、型でキャストするか、浮動小数点を使ってみてください:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ez := 1.0\nz := float64(1)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    次に値が変化しなくなった (もしくはごくわずかな変化しかしなくなった) 場合にループを停止させます。\n\n\n    それが 10 回よりも多いか少ないかを確認してください。\n\n\n    x や x/2 のように他の初期推測の値を z に与えてみてください。\n\n\n    あなたの関数の結果は標準ライブラリの \u003ca href=\"https://golang.org/pkg/math/#Sqrt\" target=\"_blank\"\u003emath.Sqrt\u003c/a\u003e にどれくらい近づきましたか？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (メモ: アルゴリズムの詳細について興味がある人のために説明すると、\n\n\n    上の z² − xという式は、z² が最終的な期待値 x からどのくらい離れているかを表しています。\n\n\n    除算の 2z は z² の導関数で、z² の変化の大きさに応じて z の調整値を変化させます。\n\n\n    この一般的なアプローチは\u003ca href=\"https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%88%E3%83%B3%E6%B3%95\" target=\"_blank\"\u003eニュートン法\u003c/a\u003eと呼ばれています。\n\n\n    多くの関数で有効ですが、平方根で特に有効です。)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-loops-and-functions.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Sqrt(x float64) float64 {\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(2))\n}\n","Hash":"gtNrJKxe1FGotKs4BtY3aDHG9hM="}]},{"Title":"Switch","Content":"\n  \u003ch2\u003eSwitch\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eswitch\u003c/code\u003e ステートメントは \u003ccode\u003eif - else\u003c/code\u003e ステートメントのシーケンスを短く書く方法です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go の switch は C や C++、Java、JavaScript、PHP の switch と似ていますが、\n\n\n    Go では選択された case だけを実行してそれに続く全ての case は実行されません。\n\n\n    これらの言語の各 case の最後に必要な \u003ccode\u003ebreak\u003c/code\u003e ステートメントが Go では自動的に提供されます。\n\n\n    もう一つの重要な違いは Go の switch の case は定数である必要はなく、\n\n\n    関係する値は整数である必要はないということです。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"switch.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tfmt.Print(\"Go runs on \")\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\\n\", os)\n\t}\n}\n","Hash":"ssXYUVr8b0W+UIdqULwjIXe5EIs="}]},{"Title":"Switch evaluation order","Content":"\n  \u003ch2\u003eSwitch evaluation order\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    switch caseは、上から下へcaseを評価します。\n\n\n    caseの条件が一致すれば、そこで停止(自動的にbreak)します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (例えば、\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eswitch i {\ncase 0:\ncase f():\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    では、 \u003ccode\u003ei==0\u003c/code\u003e であれば、 \u003ccode\u003ecase 0\u003c/code\u003e でbreakされるため \u003ccode\u003ef\u003c/code\u003e は呼び出されません)\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Note: Go playground上の時間は、いつも \u0026#34;2009-11-10 23:00:00 UTC\u0026#34; です。\n\n\n    この値の意味は、読者の楽しみのために残しておきます(^^)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"switch-evaluation-order.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"When's Saturday?\")\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println(\"Today.\")\n\tcase today + 1:\n\t\tfmt.Println(\"Tomorrow.\")\n\tcase today + 2:\n\t\tfmt.Println(\"In two days.\")\n\tdefault:\n\t\tfmt.Println(\"Too far away.\")\n\t}\n}\n","Hash":"Hevv3n4U/ccdvgrd6ETU4Y2vgkg="}]},{"Title":"Switch with no condition","Content":"\n  \u003ch2\u003eSwitch with no condition\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    条件のないswitchは、 \u003ccode\u003eswitch true\u003c/code\u003e と書くことと同じです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    このswitchの構造は、長くなりがちな \u0026#34;if-then-else\u0026#34; のつながりをシンプルに表現できます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"switch-with-no-condition.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt := time.Now()\n\tswitch {\n\tcase t.Hour() \u003c 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() \u003c 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n}\n","Hash":"03rL/Cr+GvYFECOFbBJv5IX4Q9Y="}]},{"Title":"Defer","Content":"\n  \u003ch2\u003eDefer\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003edefer\u003c/code\u003e ステートメントは、 \u003ccode\u003edefer\u003c/code\u003e へ渡した関数の実行を、呼び出し元の関数の終わり(returnする)まで遅延させるものです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003edefer\u003c/code\u003e へ渡した関数の引数は、すぐに評価されますが、その関数自体は呼び出し元の関数がreturnするまで実行されません。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"defer.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n","Hash":"2Z9b5KH9i2dp2TZu26N0xR/Af6Q="}]},{"Title":"Stacking defers","Content":"\n  \u003ch2\u003eStacking defers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003edefer\u003c/code\u003e へ渡した関数が複数ある場合、その呼び出しはスタック( \u003ci\u003estack\u003c/i\u003e )されます。\n\n\n    呼び出し元の関数がreturnするとき、 \u003ccode\u003edefer\u003c/code\u003e へ渡した関数は \u003ca href=\"https://ja.wikipedia.org/wiki/LIFO\" target=\"_blank\"\u003eLIFO(last-in-first-out)\u003c/a\u003e の順番で実行されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003edefer\u003c/code\u003e ステートメントについてさらに学ぶには、\n\n\n    \u003ca href=\"https://blog.golang.org/defer-panic-and-recover\" target=\"_blank\"\u003eこちら(blog post)\u003c/a\u003eを読んでみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"defer-multi.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i \u003c 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n","Hash":"BFzzho+ksu2wU+yyZOcnJ5z3kQg="}]},{"Title":"Congratulations!","Content":"\n  \u003ch2\u003eCongratulations!\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    この章はこれで終わりです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"/list\" target=\"_self\"\u003e章のリスト\u003c/a\u003eから学びたいところを見ても良いですし、\n\n\n    \u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e\u0026gt;\u003c/a\u003e をクリックして次の章へ進みましょう。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"methods":{"Title":"Methods and interfaces","Description":"このレッスンではメソッドとインターフェース、オブジェクトとその動作を定義する構造体について説明します。","Pages":[{"Title":"Methods","Content":"\n  \u003ch2\u003eMethods\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goには、クラス( \u003ci\u003eclass\u003c/i\u003e )のしくみはありませんが、型にメソッド( \u003ci\u003emethod\u003c/i\u003e )を定義できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    メソッドは、特別なレシーバ( \u003ci\u003ereceiver\u003c/i\u003e )引数を関数に取ります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    レシーバは、 \u003ccode\u003efunc\u003c/code\u003e キーワードとメソッド名の間に自身の引数リストで表現します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この例では、 \u003ccode\u003eAbs\u003c/code\u003e メソッドは \u003ccode\u003ev\u003c/code\u003e という名前の \u003ccode\u003eVertex\u003c/code\u003e 型のレシーバを持つことを意味しています。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n","Hash":"Ri0Y1X1RvD4ysSICFlAD0YwiciM="}]},{"Title":"Methods are functions","Content":"\n  \u003ch2\u003eMethods are functions\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    メソッドは、レシーバ引数を伴う関数、でしたね？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この \u003ccode\u003eAbs\u003c/code\u003e は、先ほどの例から機能を変えずに通常の関数として記述しています。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-funcs.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(Abs(v))\n}\n","Hash":"PKx6hnGY7gFDiHYMaaOuA0NgXYk="}]},{"Title":"Methods continued","Content":"\n  \u003ch2\u003eMethods continued\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    例で挙げたstructの型だけではなく、任意の型(type)にもメソッドを宣言できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例は、 \u003ccode\u003eAbs\u003c/code\u003e メソッドを持つ、数値型の \u003ccode\u003eMyFloat\u003c/code\u003e 型です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    レシーバを伴うメソッドの宣言は、レシーバ型が同じパッケージにある必要があります。\n\n\n    他のパッケージに定義している型に対して、レシーバを伴うメソッドを宣言できません\n\n\n    （組み込みの \u003ccode\u003eint\u003c/code\u003e などの型も同様です）。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-continued.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f \u003c 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n","Hash":"gNtDHNEf68ZV05Dn2/JqSHJO/CA="}]},{"Title":"Pointer receivers","Content":"\n  \u003ch2\u003ePointer receivers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    ポインタレシーバでメソッドを宣言できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    これはレシーバの型が、ある型 \u003ccode\u003eT\u003c/code\u003e への構文 \u003ccode\u003e*T\u003c/code\u003e があることを意味します。\n\n\n    （なお、 \u003ccode\u003eT\u003c/code\u003e は \u003ccode\u003e*int\u003c/code\u003e のようなポインタ自身を取ることはできません）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例では \u003ccode\u003e*Vertex\u003c/code\u003e に \u003ccode\u003eScale\u003c/code\u003e メソッドが定義されています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ポインタレシーバを持つメソッド(ここでは \u003ccode\u003eScale\u003c/code\u003e )は、レシーバが指す変数を変更できます。\n\n\n    レシーバ自身を更新することが多いため、変数レシーバよりもポインタレシーバの方が一般的です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eScale\u003c/code\u003e の宣言(line 16)から \u003ccode\u003e*\u003c/code\u003e を消し、プログラムの振る舞いがどう変わるのかを確認してみましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    変数レシーバでは、 \u003ccode\u003eScale\u003c/code\u003e メソッドの操作は元の \u003ccode\u003eVertex\u003c/code\u003e 変数のコピーを操作します。\n\n\n    （これは関数の引数としての振るまいと同じです）。\n\n\n    つまり \u003ccode\u003emain\u003c/code\u003e 関数で宣言した \u003ccode\u003eVertex\u003c/code\u003e 変数を変更するためには、\u003ccode\u003eScale\u003c/code\u003e メソッドはポインタレシーバにする必要があるのです。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-pointers.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10)\n\tfmt.Println(v.Abs())\n}\n","Hash":"fAxvljlTfE3Q8KGvdfBs1fyc8N8="}]},{"Title":"Pointers and functions","Content":"\n  \u003ch2\u003ePointers and functions\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    ここで、 \u003ccode\u003eAbs\u003c/code\u003e と \u003ccode\u003eScale\u003c/code\u003e メソッドは関数として書きなおしてあります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    再度、line 16から \u003ccode\u003e*\u003c/code\u003e を消してください。\n\n\n    なぜ振る舞いが変わったのかわかりますか？\n\n\n    コンパイルするために、さらに何が必要でしょうか。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (よくわからなくても、次のページに行きましょう)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-pointers-explained.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc Scale(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tScale(\u0026v, 10)\n\tfmt.Println(Abs(v))\n}\n","Hash":"UkaipHI3vU5n36ImMygcCf5cug4="}]},{"Title":"Methods and pointer indirection","Content":"\n  \u003ch2\u003eMethods and pointer indirection\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    下の2つの呼び出しを比べると、ポインタを引数に取る \u003ccode\u003eScaleFunc\u003c/code\u003e 関数は、ポインタを渡す必要があることに気がつくでしょう:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(\u0026amp;v, 5) // OK\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    メソッドがポインタレシーバである場合、呼び出し時に、変数、または、ポインタのいずれかのレシーバとして取ることができます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nv.Scale(5)  // OK\np := \u0026amp;v\np.Scale(10) // OK\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ev.Scale(5)\u003c/code\u003e のステートメントでは、 \u003ccode\u003ev\u003c/code\u003e は変数であり、ポインタではありません。\n\n\n    メソッドでポインタレシーバが自動的に呼びだされます。\n\n\n    \u003ccode\u003eScale\u003c/code\u003e メソッドはポインタレシーバを持つ場合、Goは利便性のため、 \u003ccode\u003ev.Scale(5)\u003c/code\u003e のステートメントを \u003ccode\u003e(\u0026amp;v).Scale(5)\u003c/code\u003e として解釈します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"indirection.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(2)\n\tScaleFunc(\u0026v, 10)\n\n\tp := \u0026Vertex{4, 3}\n\tp.Scale(3)\n\tScaleFunc(p, 8)\n\n\tfmt.Println(v, p)\n}\n","Hash":"vkdr6283JVw0hF1pb2IlCOpFNks="}]},{"Title":"Methods and pointer indirection (2)","Content":"\n  \u003ch2\u003eMethods and pointer indirection (2)\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    逆にも見てみましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    変数の引数を取る関数は、特定の型の変数を取る必要があります:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(\u0026amp;v)) // Compile error!\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    メソッドが変数レシーバである場合、呼び出し時に、変数、または、ポインタのいずれかのレシーバとして取ることができます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nfmt.Println(v.Abs()) // OK\np := \u0026amp;v\nfmt.Println(p.Abs()) // OK\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    この場合、 \u003ccode\u003ep.Abs()\u003c/code\u003e は \u003ccode\u003e(*p).Abs()\u003c/code\u003e として解釈されます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"indirection-values.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n\tfmt.Println(AbsFunc(v))\n\n\tp := \u0026Vertex{4, 3}\n\tfmt.Println(p.Abs())\n\tfmt.Println(AbsFunc(*p))\n}\n","Hash":"uUoieKc4jMWBn0pBQ4TNmib2Zlk="}]},{"Title":"Choosing a value or pointer receiver","Content":"\n  \u003ch2\u003eChoosing a value or pointer receiver\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    ポインタレシーバを使う2つの理由があります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ひとつは、メソッドがレシーバが指す先の変数を変更するためです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ふたつに、メソッドの呼び出し毎に変数のコピーを避けるためです。\n\n\n    例えば、レシーバが大きな構造体である場合に効率的です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例では、 \u003ccode\u003eAbs\u003c/code\u003e メソッドはレシーバ自身を変更する必要はありませんが、 \u003ccode\u003eScale\u003c/code\u003e と \u003ccode\u003eAbs\u003c/code\u003e は両方とも \u003ccode\u003e*Vertex\u003c/code\u003e 型のレシーバです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    一般的には、値レシーバ、または、ポインタレシーバのどちらかですべてのメソッドを与え、混在させるべきではありません。\n\n\n    (この理由は数ページ後にわかります)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-with-pointer-receivers.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := \u0026Vertex{3, 4}\n\tfmt.Printf(\"Before scaling: %+v, Abs: %v\\n\", v, v.Abs())\n\tv.Scale(5)\n\tfmt.Printf(\"After scaling: %+v, Abs: %v\\n\", v, v.Abs())\n}\n","Hash":"wI65OTRFYWjK10SKGOf4dt++gH8="}]},{"Title":"Interfaces","Content":"\n  \u003ch2\u003eInterfaces\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    interface(インタフェース)型は、メソッドのシグニチャの集まりで定義します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    そのメソッドの集まりを実装した値を、interface型の変数へ持たせることができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意:\u003c/b\u003e この例は、22行目でエラーになります。\n\n\n    \u003ccode\u003eAbs\u003c/code\u003e メソッドが、 \u003ccode\u003eVertex\u003c/code\u003e ではなく \u003ccode\u003e*Vertex\u003c/code\u003e の定義であり、\n\n\n    \u003ccode\u003eVertex\u003c/code\u003e が \u003ccode\u003eAbser\u003c/code\u003e インタフェースを実装していないということになるためエラーとなります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interfaces.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Abser interface {\n\tAbs() float64\n}\n\nfunc main() {\n\tvar a Abser\n\tf := MyFloat(-math.Sqrt2)\n\tv := Vertex{3, 4}\n\n\ta = f  // a MyFloat implements Abser\n\ta = \u0026v // a *Vertex implements Abser\n\n\t// In the following line, v is a Vertex (not *Vertex)\n\t// and does NOT implement Abser.\n\ta = v\n\n\tfmt.Println(a.Abs())\n}\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f \u003c 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n","Hash":"3OoEceqBGQjIXrE7w1MK8wW7yzU="}]},{"Title":"Interfaces are implemented implicitly","Content":"\n  \u003ch2\u003eInterfaces are implemented implicitly\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    型にメソッドを実装していくことによって、インタフェースを実装(満た)します。\n\n\n    インタフェースを実装することを明示的に宣言する必要はありません( \u0026#34;implements\u0026#34; キーワードは必要ありません)。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    暗黙のインターフェースは、インターフェースの定義をその実装から切り離します。\n\n\n    インターフェースの実装は、事前の取り決めなしにパッケージに現れることがあります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interfaces-are-satisfied-implicitly.go","Content":"package main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\n// This method means type T implements the interface I,\n// but we don't need to explicitly declare that it does so.\nfunc (t T) M() {\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I = T{\"hello\"}\n\ti.M()\n}\n","Hash":"9SSrQfjpROkzgOCerEmW39u7nLM="}]},{"Title":"Interface values","Content":"\n  \u003ch2\u003eInterface values\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    下記のように、インターフェースの値は、値と具体的な型のタプルのように考えることができます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003e(value, type)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    インターフェースの値は、特定の基底になる具体的な型の値を保持します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    インターフェースの値のメソッドを呼び出すと、その基底型の同じ名前のメソッドが実行されます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interface-values.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tfmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n\tfmt.Println(f)\n}\n\nfunc main() {\n\tvar i I\n\n\ti = \u0026T{\"Hello\"}\n\tdescribe(i)\n\ti.M()\n\n\ti = F(math.Pi)\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"eiIEA+Gt4mqHxwJ7UVjixA/Lnic="}]},{"Title":"Interface values with nil underlying values","Content":"\n  \u003ch2\u003eInterface values with nil underlying values\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    インターフェース自体の中にある具体的な値が nil の場合、メソッドは nil をレシーバーとして呼び出されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    いくつかの言語ではこれは null ポインター例外を引き起こしますが、Go では nil をレシーバーとして呼び出されても適切に処理するメソッドを記述するのが一般的です(この例では \u003ccode\u003eM\u003c/code\u003e メソッドのように)。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    具体的な値として nil を保持するインターフェイスの値それ自体は非 nil であることに注意してください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interface-values-with-nil.go","Content":"package main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tif t == nil {\n\t\tfmt.Println(\"\u003cnil\u003e\")\n\t\treturn\n\t}\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I\n\n\tvar t *T\n\ti = t\n\tdescribe(i)\n\ti.M()\n\n\ti = \u0026T{\"hello\"}\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"d1cP7OS65FGSVmmIKhXhW5Ffn2c="}]},{"Title":"Nil interface values","Content":"\n  \u003ch2\u003eNil interface values\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    nil インターフェースの値は、値も具体的な型も保持しません。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    呼び出す \u003ci\u003e具体的な\u003c/i\u003e メソッドを示す型がインターフェースのタプル内に存在しないため、 nil インターフェースのメソッドを呼び出すと、ランタイムエラーになります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"nil-interface-values.go","Content":"package main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"m1jbfiHj+IRAgnXILJjQBJV0WRo="}]},{"Title":"The empty interface","Content":"\n  \u003ch2\u003eThe empty interface\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    ゼロ個のメソッドを指定されたインターフェース型は、 \u003ci\u003e空のインターフェース\u003c/i\u003e と呼ばれます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003einterface{}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    空のインターフェースは、任意の型の値を保持できます。\n\n\n    (全ての型は、少なくともゼロ個のメソッドを実装しています。)\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    空のインターフェースは、未知の型の値を扱うコードで使用されます。\n\n\n    例えば、 \u003ccode\u003efmt.Print\u003c/code\u003e は \u003ccode\u003einterface{}\u003c/code\u003e 型の任意の数の引数を受け取ります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"empty-interface.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = \"hello\"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"4kA4LHru7y4jxvYduQKXrxssFu0="}]},{"Title":"Type assertions","Content":"\n  \u003ch2\u003eType assertions\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ci\u003e型アサーション\u003c/i\u003e は、インターフェースの値の基になる具体的な値を利用する手段を提供します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003et := i.(T)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    この文は、インターフェースの値 \u003ccode\u003ei\u003c/code\u003e が具体的な型 \u003ccode\u003eT\u003c/code\u003e を保持し、基になる \u003ccode\u003eT\u003c/code\u003e の値を変数 \u003ccode\u003et\u003c/code\u003e に代入することを主張します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ei\u003c/code\u003e が \u003ccode\u003eT\u003c/code\u003e を保持していない場合、この文は panic を引き起こします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    インターフェースの値が特定の型を保持しているかどうかを \u003ci\u003eテスト\u003c/i\u003e するために、型アサーションは2つの値(基になる値とアサーションが成功したかどうかを報告するブール値)を返すことができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003et, ok := i.(T)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ei\u003c/code\u003e が \u003ccode\u003eT\u003c/code\u003e を保持していれば、 \u003ccode\u003et\u003c/code\u003e は基になる値になり、 \u003ccode\u003eok\u003c/code\u003e は真(true)になります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    そうでなければ、 \u003ccode\u003eok\u003c/code\u003e は偽(false)になり、 \u003ccode\u003et\u003c/code\u003e は型 \u003ccode\u003eT\u003c/code\u003e のゼロ値になり panic は起きません。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この構文と map から読み取る構文との類似点に注意してください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-assertions.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{} = \"hello\"\n\n\ts := i.(string)\n\tfmt.Println(s)\n\n\ts, ok := i.(string)\n\tfmt.Println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.Println(f, ok)\n\n\tf = i.(float64) // panic\n\tfmt.Println(f)\n}\n","Hash":"pr1VboYZkIF99GtaIO2OF3F1slk="}]},{"Title":"Type switches","Content":"\n  \u003ch2\u003eType switches\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ci\u003e型switch\u003c/i\u003e はいくつかの型アサーションを直列に使用できる構造です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    型switchは通常のswitch文と似ていますが、型switchのcaseは型(値ではない)を指定し、それらの値は指定されたインターフェースの値が保持する値の型と比較されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eswitch v := i.(type) {\ncase T:\n    // here v has type T\ncase S:\n    // here v has type S\ndefault:\n    // no match; here v has the same type as i\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    型switchの宣言は、型アサーション \u003ccode\u003ei.(T)\u003c/code\u003e と同じ構文を持ちますが、特定の型 \u003ccode\u003eT\u003c/code\u003e はキーワード \u003ccode\u003etype\u003c/code\u003e に置き換えられます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    このswitch文は、インターフェースの値 \u003ccode\u003ei\u003c/code\u003e が 型 \u003ccode\u003eT\u003c/code\u003e または \u003ccode\u003eS\u003c/code\u003e の値を保持するかどうかをテストします。\n\n\n    \u003ccode\u003eT\u003c/code\u003e および \u003ccode\u003eS\u003c/code\u003e の各caseにおいて、変数 \u003ccode\u003ev\u003c/code\u003e はそれぞれ 型 \u003ccode\u003eT\u003c/code\u003e または \u003ccode\u003eS\u003c/code\u003e であり、 \u003ccode\u003ei\u003c/code\u003e によって保持される値を保持します。\n\n\n    defaultの場合(一致するものがない場合)、変数 \u003ccode\u003ev\u003c/code\u003e は同じインターフェース型で値は \u003ccode\u003ei\u003c/code\u003e となります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-switches.go","Content":"package main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo(\"hello\")\n\tdo(true)\n}\n","Hash":"rCrmEEtXHumb7jgXlgnkuwClmlA="}]},{"Title":"Stringers","Content":"\n  \u003ch2\u003eStringers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    もっともよく使われているinterfaceの一つに \u003ca href=\"//golang.org/pkg/fmt/\" target=\"_self\"\u003e\u003ccode\u003efmt\u003c/code\u003e パッケージ\u003c/a\u003e に定義されている \u003ca href=\"//golang.org/pkg/fmt/#Stringer\" target=\"_self\"\u003e\u003ccode\u003eStringer\u003c/code\u003e\u003c/a\u003e があります:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype Stringer interface {\n    String() string\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eStringer\u003c/code\u003e インタフェースは、stringとして表現することができる型です。\n\n\n    \u003ccode\u003efmt\u003c/code\u003e パッケージ(と、多くのパッケージ)では、変数を文字列で出力するためにこのインタフェースがあることを確認します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"stringer.go","Content":"package main\n\nimport \"fmt\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf(\"%v (%v years)\", p.Name, p.Age)\n}\n\nfunc main() {\n\ta := Person{\"Arthur Dent\", 42}\n\tz := Person{\"Zaphod Beeblebrox\", 9001}\n\tfmt.Println(a, z)\n}\n","Hash":"yDPrm3LH5/ruqqZtQwyJqimSgis="}]},{"Title":"Exercise: Stringers","Content":"\n  \u003ch2\u003eExercise: Stringers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eIPAddr\u003c/code\u003e 型を実装してみましょう\n\n\n    IPアドレスをドットで4つに区切った( \u003ci\u003edotted quad\u003c/i\u003e )表現で出力するため、 \u003ccode\u003efmt.Stringer\u003c/code\u003e インタフェースを実装してください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例えば、 \u003ccode\u003eIPAddr{1, 2, 3, 4}\u003c/code\u003e は、 \u003ccode\u003e\u0026#34;1.2.3.4\u0026#34;\u003c/code\u003e として出力するようにします。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-stringer.go","Content":"package main\n\nimport \"fmt\"\n\ntype IPAddr [4]byte\n\n// TODO: Add a \"String() string\" method to IPAddr.\n\nfunc main() {\n\thosts := map[string]IPAddr{\n\t\t\"loopback\":  {127, 0, 0, 1},\n\t\t\"googleDNS\": {8, 8, 8, 8},\n\t}\n\tfor name, ip := range hosts {\n\t\tfmt.Printf(\"%v: %v\\n\", name, ip)\n\t}\n}\n","Hash":"6yJwu1CuXiC4ulEVUQfFXVtLSIU="}]},{"Title":"Errors","Content":"\n  \u003ch2\u003eErrors\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goのプログラムは、エラーの状態を \u003ccode\u003eerror\u003c/code\u003e 値で表現します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eerror\u003c/code\u003e 型は \u003ccode\u003efmt.Stringer\u003c/code\u003e に似た組み込みのインタフェースです:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype error interface {\n    Error() string\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    ( \u003ccode\u003efmt.Stringer\u003c/code\u003e と同様に、 \u003ccode\u003efmt\u003c/code\u003e パッケージは、変数を文字列で出力する際に \u003ccode\u003eerror\u003c/code\u003e インタフェースを確認します。 )\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    よく、関数は \u003ccode\u003eerror\u003c/code\u003e 変数を返します。そして、呼び出し元はエラーが \u003ccode\u003enil\u003c/code\u003e かどうかを確認することでエラーをハンドル(取り扱い)します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei, err := strconv.Atoi(\u0026#34;42\u0026#34;)\nif err != nil {\n    fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err)\n    return\n}\nfmt.Println(\u0026#34;Converted integer:\u0026#34;, i)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    nil の \u003ccode\u003eerror\u003c/code\u003e は成功したことを示し、 nilではない \u003ccode\u003eerror\u003c/code\u003e は失敗したことを示します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"errors.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\",\n\t\te.When, e.What)\n}\n\nfunc run() error {\n\treturn \u0026MyError{\n\t\ttime.Now(),\n\t\t\"it didn't work\",\n\t}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n","Hash":"L0Wnwx4HpZxHa3I6ymeZsavC3Sc="}]},{"Title":"Exercise: Errors","Content":"\n  \u003ch2\u003eExercise: Errors\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eSqrt\u003c/code\u003e 関数を \u003ca href=\"/flowcontrol/8\" target=\"_self\"\u003e以前の演習\u003c/a\u003e からコピーし、 \u003ccode\u003eerror\u003c/code\u003e の値を返すように修正してみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eSqrt\u003c/code\u003e は、複素数をサポートしていないので、負の値が与えられたとき、nil以外のエラー値を返す必要があります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    新しい型:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype ErrNegativeSqrt float64\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    を作成してください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    そして、 \u003ccode\u003eErrNegativeSqrt(-2).Error()\u003c/code\u003e で、 \u003ccode\u003e\u0026#34;cannot Sqrt negative number: -2\u0026#34;\u003c/code\u003e を返すような:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efunc (e ErrNegativeSqrt) Error() string\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    メソッドを実装し、 \u003ccode\u003eerror\u003c/code\u003e インタフェースを満たすようにします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意:\u003c/b\u003e \u003ccode\u003eError\u003c/code\u003e メソッドの中で、 \u003ccode\u003efmt.Sprint(e)\u003c/code\u003e を呼び出すことは、無限ループのプログラムになることでしょう。\n\n\n    最初に \u003ccode\u003efmt.Sprint(float64(e))\u003c/code\u003e として \u003ccode\u003ee\u003c/code\u003e を変換しておくことで、これを避けることができます。\n\n\n    なぜでしょうか？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    負の値が与えられたとき、 \u003ccode\u003eErrNegativeSqrt\u003c/code\u003e の値を返すように \u003ccode\u003eSqrt\u003c/code\u003e 関数を修正してみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-errors.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Sqrt(x float64) (float64, error) {\n\treturn 0, nil\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(2))\n\tfmt.Println(Sqrt(-2))\n}\n","Hash":"EKinkD7zz+EfKluJKZzDvhrrNEE="}]},{"Title":"Readers","Content":"\n  \u003ch2\u003eReaders\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eio\u003c/code\u003e パッケージは、データストリームを読むことを表現する \u003ccode\u003eio.Reader\u003c/code\u003e インタフェースを規定しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Goの標準ライブラリには、ファイル、ネットワーク接続、圧縮、暗号化などで、このインタフェースの \u003ca href=\"https://golang.org/search?q=Read#Global\" target=\"_blank\"\u003e多くの実装\u003c/a\u003e があります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eio.Reader\u003c/code\u003e インタフェースは \u003ccode\u003eRead\u003c/code\u003e メソッドを持ちます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efunc (T) Read(b []byte) (n int, err error)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eRead\u003c/code\u003e は、データを与えられたバイトスライスへ入れ、入れたバイトのサイズとエラーの値を返します。\n\n\n    ストリームの終端は、 \u003ccode\u003eio.EOF\u003c/code\u003e のエラーで返します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例のコードは、 \u003ca href=\"//golang.org/pkg/strings/#Reader\" target=\"_self\"\u003e\u003ccode\u003estrings.Reader\u003c/code\u003e\u003c/a\u003e を作成し、\n\n\n    8 byte毎に読み出しています。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"reader.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Hello, Reader!\")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b)\n\t\tfmt.Printf(\"b[:n] = %q\\n\", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n","Hash":"RqUBLmjOXf3/eBY7ah885QcwgNY="}]},{"Title":"Exercise: Readers","Content":"\n  \u003ch2\u003eExercise: Readers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    ASCII文字 \u003ccode\u003e\u0026#39;A\u0026#39;\u003c/code\u003e の無限ストリームを出力する \u003ccode\u003eReader\u003c/code\u003e 型を実装してください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-reader.go","Content":"package main\n\nimport \"golang.org/x/tour/reader\"\n\ntype MyReader struct{}\n\n// TODO: Add a Read([]byte) (int, error) method to MyReader.\n\nfunc main() {\n\treader.Validate(MyReader{})\n}\n","Hash":"6sW4PjGtNz4iki66R8mgRBai0h8="}]},{"Title":"Exercise: rot13Reader","Content":"\n  \u003ch2\u003eExercise: rot13Reader\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    よくあるパターンは、別の \u003ccode\u003eio.Reader\u003c/code\u003e をラップし、ストリームの内容を何らかの方法で変換する\u003ca href=\"https://golang.org/pkg/io/#Reader\" target=\"_blank\"\u003eio.Reader\u003c/a\u003eです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例えば、 \u003ca href=\"https://golang.org/pkg/compress/gzip/#NewReader\" target=\"_blank\"\u003egzip.NewReader\u003c/a\u003e は、 \u003ccode\u003eio.Reader\u003c/code\u003e (gzipされたデータストリーム)を引数で受け取り、 \u003ccode\u003e*gzip.Reader\u003c/code\u003e を返します。\n\n\n    その \u003ccode\u003e*gzip.Reader\u003c/code\u003e は、 \u003ccode\u003eio.Reader\u003c/code\u003e (展開したデータストリーム)を実装しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eio.Reader\u003c/code\u003e を実装し、 \u003ccode\u003eio.Reader\u003c/code\u003e で\u003ca href=\"https://ja.wikipedia.org/wiki/ROT13\" target=\"_blank\"\u003eROT13\u003c/a\u003e 換字式暗号( \u003ci\u003esubstitution cipher\u003c/i\u003e )をすべてのアルファベットの文字に適用して読み出すように \u003ccode\u003erot13Reader\u003c/code\u003e を実装してみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003erot13Reader\u003c/code\u003e 型は提供済みです。\n\n\n    この \u003ccode\u003eRead\u003c/code\u003e メソッドを実装することで \u003ccode\u003eio.Reader\u003c/code\u003e インタフェースを満たしてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-rot-reader.go","Content":"package main\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype rot13Reader struct {\n\tr io.Reader\n}\n\nfunc main() {\n\ts := strings.NewReader(\"Lbh penpxrq gur pbqr!\")\n\tr := rot13Reader{s}\n\tio.Copy(os.Stdout, \u0026r)\n}\n","Hash":"XPnNEi79ZGAvQXBKmWMSdJasF8g="}]},{"Title":"Images","Content":"\n  \u003ch2\u003eImages\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ca href=\"https://golang.org/pkg/image/#Image\" target=\"_blank\"\u003e\u003ccode\u003eimage\u003c/code\u003e\u003c/a\u003e パッケージは、以下の \u003ccode\u003eImage\u003c/code\u003e インタフェースを定義しています：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003epackage image\n\ntype Image interface {\n    ColorModel() color.Model\n    Bounds() Rectangle\n    At(x, y int) color.Color\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    Note: \u003ccode\u003eBounds\u003c/code\u003e メソッドの戻り値である \u003ccode\u003eRectangle\u003c/code\u003e は、 \u003ccode\u003eimage\u003c/code\u003e パッケージの\n\n\n    \u003ca href=\"https://golang.org/pkg/image/#Rectangle\" target=\"_blank\"\u003e\u003ccode\u003eimage.Rectangle\u003c/code\u003e\u003c/a\u003e\n\n\n    に定義があります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (詳細は、 \u003ca href=\"https://golang.org/pkg/image/#Image\" target=\"_blank\"\u003eこのドキュメント\u003c/a\u003e を参照してください。)\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ecolor.Color\u003c/code\u003e と \u003ccode\u003ecolor.Model\u003c/code\u003e は共にインタフェースですが、定義済みの \u003ccode\u003ecolor.RGBA\u003c/code\u003e と \u003ccode\u003ecolor.RGBAModel\u003c/code\u003e を使うことで、このインタフェースを無視できます。\n\n\n    これらのインタフェースは、\u003ca href=\"https://golang.org/pkg/image/color/\" target=\"_blank\"\u003eimage/color\u003c/a\u003e パッケージで定義されています。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"images.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n)\n\nfunc main() {\n\tm := image.NewRGBA(image.Rect(0, 0, 100, 100))\n\tfmt.Println(m.Bounds())\n\tfmt.Println(m.At(0, 0).RGBA())\n}\n","Hash":"V0zUjPfdo4VBN4QyphuqbhHFKR8="}]},{"Title":"Exercise: Images","Content":"\n  \u003ch2\u003eExercise: Images\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    前に解いた、 \u003ca href=\"/moretypes/18\" target=\"_self\"\u003e画像ジェネレーター\u003c/a\u003e　を覚えていますか？\n\n\n    今回は、データのスライスの代わりに \u003ccode\u003eimage.Image\u003c/code\u003e インタフェースの実装を返すようにしてみましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    自分の \u003ccode\u003eImage\u003c/code\u003e 型を定義し、 \u003ca href=\"https://golang.org/pkg/image/#Image\" target=\"_blank\"\u003eインタフェースを満たすのに必要なメソッド\u003c/a\u003e を実装し、 \u003ccode\u003epic.ShowImage\u003c/code\u003e を呼び出してみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eBounds\u003c/code\u003e は、 \u003ccode\u003eimage.Rect(0, 0, w, h)\u003c/code\u003e のようにして \u003ccode\u003eimage.Rectangle\u003c/code\u003e を返すようにします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eColorModel\u003c/code\u003e は、 \u003ccode\u003ecolor.RGBAModel\u003c/code\u003e を返すようにします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eAt\u003c/code\u003e は、ひとつの色を返します。\n\n\n    生成する画像の色の値 \u003ccode\u003ev\u003c/code\u003e を \u003ccode\u003ecolor.RGBA{v, v, 255, 255}\u003c/code\u003e を利用して返すようにします。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-images.go","Content":"package main\n\nimport \"golang.org/x/tour/pic\"\n\ntype Image struct{}\n\nfunc main() {\n\tm := Image{}\n\tpic.ShowImage(m)\n}\n","Hash":"Dwmfm74h39vycGjq0+RRDHA66CM="}]},{"Title":"Congratulations!","Content":"\n  \u003ch2\u003eCongratulations!\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    この章はこれで終わりです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"/list\" target=\"_self\"\u003e章のリスト\u003c/a\u003eから学びたいところを見ても良いですし、\n\n\n    \u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e\u0026gt;\u003c/a\u003e をクリックして次の章へ進みましょう。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"moretypes":{"Title":"More types: structs, slices, and maps.","Description":"既存の型に基づいて新しい型を定義する方法を学ぶ: このレッスンでは構造体、配列、slice、map について説明します。","Pages":[{"Title":"Pointers","Content":"\n  \u003ch2\u003ePointers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goはポインタを扱います。\n\n\n    ポインタは値のメモリアドレスを指します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    変数 \u003ccode\u003eT\u003c/code\u003e のポインタは、 \u003ccode\u003e*T\u003c/code\u003e 型で、ゼロ値は \u003ccode\u003enil\u003c/code\u003e です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar p *int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003e\u0026amp;\u003c/code\u003e オペレータは、そのオペランド( \u003ci\u003eoperand\u003c/i\u003e )へのポインタを引き出します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei := 42\np = \u0026amp;i\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003e*\u003c/code\u003e オペレータは、ポインタの指す先の変数を示します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efmt.Println(*p) // ポインタpを通してiから値を読みだす\n*p = 21         // ポインタpを通してiへ値を代入する\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    これは \u0026#34;dereferencing\u0026#34; または \u0026#34;indirecting\u0026#34; としてよく知られています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    なお、C言語とは異なり、ポインタ演算はありません。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"pointers.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := \u0026i         // point to i\n\tfmt.Println(*p) // read i through the pointer\n\t*p = 21         // set i through the pointer\n\tfmt.Println(i)  // see the new value of i\n\n\tp = \u0026j         // point to j\n\t*p = *p / 37   // divide j through the pointer\n\tfmt.Println(j) // see the new value of j\n}\n","Hash":"i+Ht96dGPTEcg2FJF7q5RseXBDI="}]},{"Title":"Structs","Content":"\n  \u003ch2\u003eStructs\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003estruct\u003c/code\u003e (構造体)は、フィールド( \u003ci\u003efield\u003c/i\u003e )の集まりです。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"structs.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tfmt.Println(Vertex{1, 2})\n}\n","Hash":"Ogg/+09TFU5IkZ2RcCCZsHf+2fo="}]},{"Title":"Struct Fields","Content":"\n  \u003ch2\u003eStruct Fields\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    structのフィールドは、ドット( \u003ccode\u003e.\u003c/code\u003e )を用いてアクセスします。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"struct-fields.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n","Hash":"ghPOKvMr3gvwG4M0Z4zg3Bpwgpg="}]},{"Title":"Pointers to structs","Content":"\n  \u003ch2\u003ePointers to structs\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    structのフィールドは、structのポインタを通してアクセスすることもできます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    フィールド \u003ccode\u003eX\u003c/code\u003e を持つstructのポインタ \u003ccode\u003ep\u003c/code\u003e がある場合、フィールド \u003ccode\u003eX\u003c/code\u003e にアクセスするには \u003ccode\u003e(*p).X\u003c/code\u003e のように書くことができます。\n\n\n    しかし、この表記法は大変面倒ですので、Goでは代わりに \u003ccode\u003ep.X\u003c/code\u003e と書くこともできます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"struct-pointers.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tp := \u0026v\n\tp.X = 1e9\n\tfmt.Println(v)\n}\n","Hash":"m85TYBjwWGtTynTtt1+951KkQro="}]},{"Title":"Struct Literals","Content":"\n  \u003ch2\u003eStruct Literals\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    structリテラルは、フィールドの値を列挙することで新しいstructの初期値の割り当てを示しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eName:\u003c/code\u003e 構文を使って、フィールドの一部だけを列挙することができます(この方法でのフィールドの指定順序は関係ありません)。\n\n\n    例では \u003ccode\u003eX: 1\u003c/code\u003e として \u003ccode\u003eX\u003c/code\u003e だけを初期化しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003e\u0026amp;\u003c/code\u003e を頭に付けると、新しく割り当てられたstructへのポインタを戻します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"struct-literals.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y int\n}\n\nvar (\n\tv1 = Vertex{1, 2}  // has type Vertex\n\tv2 = Vertex{X: 1}  // Y:0 is implicit\n\tv3 = Vertex{}      // X:0 and Y:0\n\tp  = \u0026Vertex{1, 2} // has type *Vertex\n)\n\nfunc main() {\n\tfmt.Println(v1, p, v2, v3)\n}\n","Hash":"EFcXlUPwNHEgPnj9+DjstTj4J+M="}]},{"Title":"Arrays","Content":"\n  \u003ch2\u003eArrays\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003e[n]T\u003c/code\u003e 型は、型 \u003ccode\u003eT\u003c/code\u003e の \u003ccode\u003en\u003c/code\u003e 個の変数の配列( \u003ci\u003earray\u003c/i\u003e )を表します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    以下は、intの10個の配列を宣言しています:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar a [10]int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    配列の長さは、型の一部分です。ですので、配列のサイズを変えることはできません。\n\n\n    これは制約のように思えますが、心配しないでください。\n\n\n    Goは配列を扱うための便利な方法を提供しています。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"array.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [2]string\n\ta[0] = \"Hello\"\n\ta[1] = \"World\"\n\tfmt.Println(a[0], a[1])\n\tfmt.Println(a)\n\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(primes)\n}\n","Hash":"XKucdSMaX+YMKsilkKDJ0Dpqosw="}]},{"Title":"Slices","Content":"\n  \u003ch2\u003eSlices\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    配列は固定長です。一方で、スライスは可変長です。より柔軟な配列と見なすこともできます。\n\n\n    実際には、スライスは配列よりもより一般的です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    型 \u003ccode\u003e[]T\u003c/code\u003e は 型 \u003ccode\u003eT\u003c/code\u003e のスライスを表します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    コロンで区切られた二つのインデックス low と high の境界を指定することによってスライスが形成されます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea[low : high]\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    これは最初の要素は含むが、最後の要素は除いた半開区間を選択します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    次の式は a の要素の内 1 から 3 を含むスライスを作ります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea[1:4]\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slices.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\n\tvar s []int = primes[1:4]\n\tfmt.Println(s)\n}\n","Hash":"tGAAck8epB4KGh6NPwHBhTpmQPM="}]},{"Title":"Slices are like references to arrays","Content":"\n  \u003ch2\u003eSlices are like references to arrays\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスは配列への参照のようなものです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スライスはどんなデータも格納しておらず、単に元の配列の部分列を指し示しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スライスの要素を変更すると、その元となる配列の対応する要素が変更されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    同じ元となる配列を共有している他のスライスは、それらの変更が反映されます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slices-pointers.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n","Hash":"RvHDudRqbwu/hRt7emjDaeWE4CI="}]},{"Title":"Slice literals","Content":"\n  \u003ch2\u003eSlice literals\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスのリテラルは長さのない配列リテラルのようなものです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    これは配列リテラルです:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003e[3]bool{true, true, false}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    そして、これは上記と同様の配列を作成し、それを参照するスライスを作成します:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003e[]bool{true, true, false}\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slice-literals.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tq := []int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(q)\n\n\tr := []bool{true, false, true, true, false, true}\n\tfmt.Println(r)\n\n\ts := []struct {\n\t\ti int\n\t\tb bool\n\t}{\n\t\t{2, true},\n\t\t{3, false},\n\t\t{5, true},\n\t\t{7, true},\n\t\t{11, false},\n\t\t{13, true},\n\t}\n\tfmt.Println(s)\n}\n","Hash":"YuPRaUOZUWgeLJPhkSqy8UltIlU="}]},{"Title":"Slice defaults","Content":"\n  \u003ch2\u003eSlice defaults\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスするときは、それらの既定値を代わりに使用することで上限または下限を省略することができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    既定値は下限が 0 で上限はスライスの長さです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    以下の配列において\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar a [10]int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    これらのスライス式は等価です:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea[0:10]\na[:10]\na[0:]\na[:]\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slice-bounds.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\n\ts = s[1:4]\n\tfmt.Println(s)\n\n\ts = s[:2]\n\tfmt.Println(s)\n\n\ts = s[1:]\n\tfmt.Println(s)\n}\n","Hash":"126LTJWLpCX7iNszKYg/L7YEZxk="}]},{"Title":"Slice length and capacity","Content":"\n  \u003ch2\u003eSlice length and capacity\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスは長さ( \u003ci\u003elength\u003c/i\u003e )と容量( \u003ci\u003ecapacity\u003c/i\u003e )の両方を持っています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スライスの長さは、それに含まれる要素の数です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スライスの容量は、スライスの最初の要素から数えて、元となる配列の要素数です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スライス \u003ccode\u003es\u003c/code\u003e の長さと容量は \u003ccode\u003elen(s)\u003c/code\u003e と \u003ccode\u003ecap(s)\u003c/code\u003e という式を使用して得ることができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    十分な容量を持って提供されているスライスを再スライスすることによって、スライスの長さを伸ばすことができます。\n\n\n    その容量を超えて伸ばしたときに何が起こるかを見るため、プログラム例でのスライスのいずれかの操作を変更してみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slice-len-cap.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// Slice the slice to give it zero length.\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// Extend its length.\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// Drop its first two values.\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n","Hash":"kCcGGXYSE7FIvqMQhtNwpkn+kEY="}]},{"Title":"Nil slices","Content":"\n  \u003ch2\u003eNil slices\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスのゼロ値は \u003ccode\u003enil\u003c/code\u003e です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003enil\u003c/code\u003e スライスは 0 の長さと容量を持っており、何の元となる配列も持っていません。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"nil-slices.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int\n\tfmt.Println(s, len(s), cap(s))\n\tif s == nil {\n\t\tfmt.Println(\"nil!\")\n\t}\n}\n","Hash":"2gyXCfVBBtLAlqnLlLviWtSEVdA="}]},{"Title":"Creating a slice with make","Content":"\n  \u003ch2\u003eCreating a slice with make\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスは、組み込みの \u003ccode\u003emake\u003c/code\u003e 関数を使用して作成することができます。\n\n\n    これは、動的サイズの配列を作成する方法です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003emake\u003c/code\u003e 関数はゼロ化された配列を割り当て、その配列を指すスライスを返します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea := make([]int, 5)  // len(a)=5\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003emake\u003c/code\u003e の3番目の引数に、スライスの容量( \u003ci\u003ecapacity\u003c/i\u003e )を指定できます。\n\n\n    \u003ccode\u003ecap(b)\u003c/code\u003e で、スライスの容量を返します:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"making-slices.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := make([]int, 5)\n\tprintSlice(\"a\", a)\n\n\tb := make([]int, 0, 5)\n\tprintSlice(\"b\", b)\n\n\tc := b[:2]\n\tprintSlice(\"c\", c)\n\n\td := c[2:5]\n\tprintSlice(\"d\", d)\n}\n\nfunc printSlice(s string, x []int) {\n\tfmt.Printf(\"%s len=%d cap=%d %v\\n\",\n\t\ts, len(x), cap(x), x)\n}\n","Hash":"/jN/up0H3+B/fuCVJtDq/ed1B8w="}]},{"Title":"Slices of slices","Content":"\n  \u003ch2\u003eSlices of slices\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスは、他のスライスを含む任意の型を含むことができます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slices-of-slice.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Create a tic-tac-toe board.\n\tboard := [][]string{\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t}\n\n\t// The players take turns.\n\tboard[0][0] = \"X\"\n\tboard[2][2] = \"O\"\n\tboard[1][2] = \"X\"\n\tboard[1][0] = \"O\"\n\tboard[0][2] = \"X\"\n\n\tfor i := 0; i \u003c len(board); i++ {\n\t\tfmt.Printf(\"%s\\n\", strings.Join(board[i], \" \"))\n\t}\n}\n","Hash":"/8SscyOYcdD+cKUcGRMn+bu+z/s="}]},{"Title":"Appending to a slice","Content":"\n  \u003ch2\u003eAppending to a slice\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    スライスへ新しい要素を追加するには、Goの組み込みの \u003ccode\u003eappend\u003c/code\u003e を使います。\n\n\n    \u003ccode\u003eappend\u003c/code\u003e についての詳細は \u003ca href=\"https://golang.org/pkg/builtin/#append\" target=\"_blank\"\u003edocumentation\u003c/a\u003e を参照してみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efunc append(s []T, vs ...T) []T\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    上の定義を見てみましょう。 \u003ccode\u003eappend\u003c/code\u003e への最初のパラメータ \u003ccode\u003es\u003c/code\u003e は、追加元となる \u003ccode\u003eT\u003c/code\u003e 型のスライスです。\n\n\n    残りの \u003ccode\u003evs\u003c/code\u003e は、追加する \u003ccode\u003eT\u003c/code\u003e 型の変数群です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eappend\u003c/code\u003e の戻り値は、追加元のスライスと追加する変数群を合わせたスライスとなります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    もし、元の配列 \u003ccode\u003es\u003c/code\u003e が、変数群を追加する際に容量が小さい場合は、より大きいサイズの配列を割り当て直します。\n\n\n    その場合、戻り値となるスライスは、新しい割当先を示すようになります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (スライスについてより詳しく学ぶには、\u003ca href=\"https://blog.golang.org/go-slices-usage-and-internals\" target=\"_blank\"\u003eSlices: usage and internals\u003c/a\u003eを読んでみてください)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"append.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int\n\tprintSlice(s)\n\n\t// append works on nil slices.\n\ts = append(s, 0)\n\tprintSlice(s)\n\n\t// The slice grows as needed.\n\ts = append(s, 1)\n\tprintSlice(s)\n\n\t// We can add more than one element at a time.\n\ts = append(s, 2, 3, 4)\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n","Hash":"L+wfqhUrWgkLDxWCWN4wbYtQYjc="}]},{"Title":"Range","Content":"\n  \u003ch2\u003eRange\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003efor\u003c/code\u003e ループに利用する \u003ccode\u003erange\u003c/code\u003e は、スライスや、マップ( \u003ccode\u003emap\u003c/code\u003e )をひとつずつ反復処理するために使います。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スライスをrangeで繰り返す場合、rangeは反復毎に2つの変数を返します。\n\n\n    1つ目の変数はインデックス( \u003ci\u003eindex\u003c/i\u003e )で、2つ目はインデックスの場所の要素のコピーです。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"range.go","Content":"package main\n\nimport \"fmt\"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n","Hash":"TrnpTuf792EXlQom9L3gMkUkz6U="}]},{"Title":"Range continued","Content":"\n  \u003ch2\u003eRange continued\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    インデックスや値は、 \u0026#34; \u003ccode\u003e_\u003c/code\u003e \u0026#34;(アンダーバー) へ代入することで捨てることができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efor i, _ := range pow\nfor _, value := range pow\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    もしインデックスだけが必要なのであれば、2つ目の値を省略します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efor i := range pow\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"range-continued.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tpow := make([]int, 10)\n\tfor i := range pow {\n\t\tpow[i] = 1 \u003c\u003c uint(i) // == 2**i\n\t}\n\tfor _, value := range pow {\n\t\tfmt.Printf(\"%d\\n\", value)\n\t}\n}\n","Hash":"4B84qCi5dJR2qWuL6NhqWoy1TiY="}]},{"Title":"Exercise: Slices","Content":"\n  \u003ch2\u003eExercise: Slices\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003ePic\u003c/code\u003e 関数を実装してみましょう。\n\n\n    このプログラムを実行すると、生成した画像が下に表示されるはずです。\n\n\n    この関数は、長さ \u003ccode\u003edy\u003c/code\u003e のsliceに、各要素が8bitのunsigned int型で長さ \u003ccode\u003edx\u003c/code\u003e のsliceを割り当てたものを返すように実装する必要があります。\n\n\n    画像は、整数値をグレースケール(実際はブルースケール)として解釈したものです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    生成する画像は、好きに選んでください。例えば、面白い関数に、 \u003ccode\u003e(x+y)/2\u003c/code\u003e 、 \u003ccode\u003ex*y\u003c/code\u003e 、 \u003ccode\u003ex^y\u003c/code\u003e などがあります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ヒント:( \u003ccode\u003e[][]uint8\u003c/code\u003e に、各 \u003ccode\u003e[]uint8\u003c/code\u003e を割り当てるためにループを使用する必要があります)\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ヒント:( \u003ccode\u003euint8(intValue)\u003c/code\u003e を型の変換のために使います)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-slices.go","Content":"package main\n\nimport \"golang.org/x/tour/pic\"\n\nfunc Pic(dx, dy int) [][]uint8 {\n}\n\nfunc main() {\n\tpic.Show(Pic)\n}\n","Hash":"kyr5jSqLKV1sQT6BThG9dVbEe8s="}]},{"Title":"Maps","Content":"\n  \u003ch2\u003eMaps\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003emap\u003c/code\u003e はキーと値とを関連付けます(マップします)。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    マップのゼロ値は \u003ccode\u003enil\u003c/code\u003e です。\n\n\n    \u003ccode\u003enil\u003c/code\u003e マップはキーを持っておらず、またキーを追加することもできません。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003emake\u003c/code\u003e 関数は指定された型のマップを初期化して、使用可能な状態で返します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"maps.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m map[string]Vertex\n\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm[\"Bell Labs\"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m[\"Bell Labs\"])\n}\n","Hash":"rht5fv2C9kBGGZcCMrdHAdDZMWQ="}]},{"Title":"Map literals","Content":"\n  \u003ch2\u003eMap literals\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    mapリテラルは、structリテラルに似ていますが、 \u003cb\u003eキー\u003c/b\u003e ( \u003ci\u003ekey\u003c/i\u003e )が必要です。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"map-literals.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": Vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t\"Google\": Vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n","Hash":"rWlZxNfgDt0zX5TH6PVvJJDyQnM="}]},{"Title":"Map literals continued","Content":"\n  \u003ch2\u003eMap literals continued\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    もし、mapに渡すトップレベルの型が単純な型名である場合は、リテラルの要素から推定できますので、その型名を省略することができます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"map-literals-continued.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n","Hash":"TfQqduBfdaXr+Lxb7DX9DaIMakg="}]},{"Title":"Mutating Maps","Content":"\n  \u003ch2\u003eMutating Maps\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    map \u003ccode\u003em\u003c/code\u003e の操作を見ていきましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003em\u003c/code\u003e へ要素(elem)の挿入や更新:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003em[key] = elem\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    要素の取得:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eelem = m[key]\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    要素の削除:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003edelete(m, key)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    キーに対する要素が存在するかどうかは、2つの目の値で確認します:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eelem, ok = m[key]\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    もし、 \u003ccode\u003em\u003c/code\u003e に \u003ccode\u003ekey\u003c/code\u003e があれば、変数 \u003ccode\u003eok\u003c/code\u003e は \u003ccode\u003etrue\u003c/code\u003e となり、存在しなければ、 \u003ccode\u003eok\u003c/code\u003e は \u003ccode\u003efalse\u003c/code\u003e となります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    なお、mapに \u003ccode\u003ekey\u003c/code\u003e が存在しない場合、 \u003ccode\u003eelem\u003c/code\u003e はmapの要素の型のゼロ値となります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003eNote:\u003c/b\u003e もし \u003ccode\u003eelem\u003c/code\u003e や \u003ccode\u003eok\u003c/code\u003e をまだ宣言していなければ、次のように \u003ccode\u003e:=\u003c/code\u003e で短く宣言できます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eelem, ok := m[key]\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"mutating-maps.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := make(map[string]int)\n\n\tm[\"Answer\"] = 42\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tm[\"Answer\"] = 48\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tdelete(m, \"Answer\")\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tv, ok := m[\"Answer\"]\n\tfmt.Println(\"The value:\", v, \"Present?\", ok)\n}\n","Hash":"Yb5V377DiiLAd8aCfxxtC0S/sdc="}]},{"Title":"Exercise: Maps","Content":"\n  \u003ch2\u003eExercise: Maps\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eWordCount\u003c/code\u003e 関数を実装してみましょう。string \u003ccode\u003es\u003c/code\u003e で渡される文章の、各単語の出現回数のmapを返す必要があります。\n\n\n    \u003ccode\u003ewc.Test\u003c/code\u003e 関数は、引数に渡した関数に対しテストスイートを実行し、成功か失敗かを結果に表示します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"https://golang.org/pkg/strings/#Fields\" target=\"_blank\"\u003estrings.Fields\u003c/a\u003e で、何かヒントを得ることができるはずです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Note: このテストスイートで何を入力とし、何を期待しているかについては、\u003ca href=\"https://github.com/golang/tour/blob/master/wc/wc.go\" target=\"_blank\"\u003egolang.org/x/tour/wc\u003c/a\u003eを見てみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-maps.go","Content":"package main\n\nimport (\n\t\"golang.org/x/tour/wc\"\n)\n\nfunc WordCount(s string) map[string]int {\n\treturn map[string]int{\"x\": 1}\n}\n\nfunc main() {\n\twc.Test(WordCount)\n}\n","Hash":"412+IoCx6S2as89oIhOsgqFJUUM="}]},{"Title":"Function values","Content":"\n  \u003ch2\u003eFunction values\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数も変数です。他の変数のように関数を渡すことができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    関数値( \u003ci\u003efunction value\u003c/i\u003e )は、関数の引数に取ることもできますし、戻り値としても利用できます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"function-values.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\n\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.Sqrt(x*x + y*y)\n\t}\n\tfmt.Println(hypot(5, 12))\n\n\tfmt.Println(compute(hypot))\n\tfmt.Println(compute(math.Pow))\n}\n","Hash":"/ZOMEENCqbM+TbJAYLHcNv60gfY="}]},{"Title":"Function closures","Content":"\n  \u003ch2\u003eFunction closures\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goの関数は \u003ca href=\"https://ja.wikipedia.org/wiki/クロージャ\" target=\"_blank\"\u003eクロージャ( \u003ci\u003eclosure\u003c/i\u003e )\u003c/a\u003e です。\n\n\n    クロージャは、それ自身の外部から変数を参照する関数値です。\n\n\n    この関数は、参照された変数へアクセスして変えることができ、その意味では、その関数は変数へ\u0026#34;バインド\u0026#34;( \u003ci\u003ebind\u003c/i\u003e )されています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例えば、 \u003ccode\u003eadder\u003c/code\u003e 関数はクロージャを返しています。\n\n\n    各クロージャは、それ自身の \u003ccode\u003esum\u003c/code\u003e 変数へバインドされます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"function-closures.go","Content":"package main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i \u003c 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n","Hash":"XQlACZHW1Wkhc0nZnpZGvrVgkWo="}]},{"Title":"Exercise: Fibonacci closure","Content":"\n  \u003ch2\u003eExercise: Fibonacci closure\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数を用いた面白い例を見てみましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003efibonacci\u003c/code\u003e (フィボナッチ)関数を実装しましょう。この関数は、連続する\u003ca href=\"https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0\" target=\"_blank\"\u003eフィボナッチ数\u003c/a\u003e(0, 1, 1, 2, 3, 5, ...)を返す関数(クロージャ)を返します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-fibonacci-closure.go","Content":"package main\n\nimport \"fmt\"\n\n// fibonacci is a function that returns\n// a function that returns an int.\nfunc fibonacci() func() int {\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i \u003c 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n","Hash":"BQXS8AUg/LPWf2asWqi6FZl1+aU="}]},{"Title":"Congratulations!","Content":"\n  \u003ch2\u003eCongratulations!\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    この章はこれで終わりです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"/list\" target=\"_self\"\u003e章のリスト\u003c/a\u003eから学びたいところを見ても良いですし、\n\n\n    \u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e\u0026gt;\u003c/a\u003e をクリックして次の章へ進みましょう。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"welcome":{"Title":"Welcome!","Description":"この Tour の使い方を学びましょう: さまざまなレッスンを切り替える方法やコードの実行方法が含まれます。","Pages":[{"Title":"Hello, 世界","Content":"\n  \u003ch2\u003eHello, 世界\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ca href=\"https://golang.org/\" target=\"_blank\"\u003eプログラミング言語Go\u003c/a\u003e Tour  ( \u003cb\u003eGo言語基礎文法最速マスター\u003c/b\u003e ) へようこそ！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go Tour は複数の章で構成されています。\n\n\n    \u003ca href=\"javascript:highlight(\u0026#34;.logo\u0026#34;)\" target=\"_self\"\u003e左上の A Tour of Go から辿ることができます。\u003c/a\u003e\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    また、目次は\n\n\n    \u003ca href=\"javascript:highlightAndClick(\u0026#34;.nav\u0026#34;)\" target=\"_self\"\u003e右上の menu をクリックすることでいつでも参照できます。\u003c/a\u003e\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go Tour は、一連のスライドと演習課題(Exercise)で構成されています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ページを切り替えるには:\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e\u003ca href=\"javascript:highlight(\u0026#34;.prev-page\u0026#34;)\" target=\"_self\"\u003e下の\u0026lt;\u003c/a\u003e または \u003ccode\u003ePageUp\u003c/code\u003e で前のページ\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \u003cul\u003e\n  \n    \u003cli\u003e\u003ca href=\"javascript:highlight(\u0026#34;.next-page\u0026#34;)\" target=\"_self\"\u003e下の\u0026gt;\u003c/a\u003e または \u003ccode\u003ePageDown\u003c/code\u003e で次のページ\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    で移動できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go Tour はインタラクティブです。\n\n\n    \u003ca href=\"javascript:highlightAndClick(\u0026#34;#run\u0026#34;)\" target=\"_self\"\u003eRunボタンをクリック\u003c/a\u003e(もしくは \u003ccode\u003eShift\u003c/code\u003e + \u003ccode\u003eEnter\u003c/code\u003e)\n\n\n    すると、コードが\n\n\n    リモートのサーバ\n\n\n    でコンパイルされ、実行されます。\n\n\n    実行結果はコードの下に表示されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    これらのコードは、Go言語の様々な特徴を示しています。 Go Tour にあるプログラムは、Goを学習するための出発点となることでしょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    さっそくコードを修正し、実行してみましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"javascript:highlightAndClick(\u0026#34;#format\u0026#34;)\" target=\"_self\"\u003eFormatボタンをクリック\u003c/a\u003e、または \u003ccode\u003eCtrl\u003c/code\u003e + \u003ccode\u003eEnter\u003c/code\u003e でコードをフォーマット(整形)します。\n\n\n    これは \u003ca href=\"https://golang.org/cmd/gofmt/\" target=\"_blank\"\u003egofmt\u003c/a\u003e コマンドを利用しています。\n\n\n    Goのコードを書く際は、必ずこのツールを一緒に使いましょう。\n\n\n    \u003ca href=\"javascript:highlightAndClick(\u0026#34;.syntax-checkbox\u0026#34;)\" target=\"_self\"\u003esyntaxボタンをクリック\u003c/a\u003eするとシンタックスハイライトの切り替えができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    準備ができたら、次のページへ進みましょう！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    注：本サイト \u0026#34;A Tour of Go\u0026#34; は、 \u003ca href=\"https://tour.golang.org\" target=\"_blank\"\u003eA Tour of Go\u003c/a\u003e を日本語訳したものです。日本語翻訳プロジェクトは\u003ca href=\"https://github.com/atotto/go-tour-jp\" target=\"_blank\"\u003eこちら\u003c/a\u003eです。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"hello.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, 世界\")\n}\n","Hash":"DwfZCJ2NK3FTIJnSUkZkwzma41c="}]},{"Title":"Go local","Content":"\n  \u003ch2\u003eGo local\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go Tour は他の言語でも利用できます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    The tour is available in other languages:\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://tour.golang.org/\" target=\"_blank\"\u003eEnglish - 英語\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ar.appspot.com/\" target=\"_blank\"\u003eArabic — العربية\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-br.appspot.com/\" target=\"_blank\"\u003eBrazilian Portuguese — Português do Brasil\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ca.appspot.com/\" target=\"_blank\"\u003eCatalan — Català\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://tour.go-zh.org/\" target=\"_blank\"\u003eSimplified Chinese — 中文（简体）\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-zh-tw.appspot.com/\" target=\"_blank\"\u003eTraditional Chinese — 中文（繁體）\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-cz.appspot.com/\" target=\"_blank\"\u003eCzech — Česky\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-fr.appspot.com/\" target=\"_blank\"\u003eFrench — Français\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-de.appspot.com/\" target=\"_blank\"\u003eGerman — Deutsch\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-he.appspot.com/\" target=\"_blank\"\u003eHebrew — עִבְרִית\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-id2.appspot.com/\" target=\"_blank\"\u003eIndonesian — Bahasa Indonesia\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ita.appspot.com/\" target=\"_blank\"\u003eItalian — Italiano\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-kr.appspot.com/\" target=\"_blank\"\u003eKorean — 한국어\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ro.appspot.com/\" target=\"_blank\"\u003eRomanian — Română\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ru-ru.appspot.com/\" target=\"_blank\"\u003eRussian - Русский\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://gotour-es.appspot.com/\" target=\"_blank\"\u003eSpanish — Español\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-th.appspot.com/\" target=\"_blank\"\u003eThai - ภาษาไทย\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-turkish.appspot.com/\" target=\"_blank\"\u003eTurkish - Türkçe\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ua.appspot.com/\" target=\"_blank\"\u003eUkrainian — Українська\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-uz.appspot.com/\" target=\"_blank\"\u003eUzbek — Ўзбекча\u003c/a\u003e\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    \u003ca href=\"javascript:highlightAndClick(\u0026#34;.next-page\u0026#34;)\" target=\"_self\"\u003e\u0026#34;next\u0026#34; ボタンをクリック\u003c/a\u003e するか \u003ccode\u003ePageDown\u003c/code\u003e で進みましょう。\n  \u003c/p\u003e\n  \n\n","Files":[]},{"Title":"Go offline","Content":"\n  \u003ch2\u003eGo offline\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    この Go Tour はスタンドアロンのプログラムとして動かすこともできます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    スタンドアロンの Go Tour は、自身のマシンでコードをビルドし、実行するため、より高速になります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ローカルで Go Tour を実行するためには、はじめに、\n\n\n    \u003ca href=\"https://golang.org/dl/\" target=\"_blank\"\u003eGoのダウンロードとインストール\u003c/a\u003e\n\n\n    し、コマンドラインで以下のように実行します:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ego tool tour\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    上記のコマンドの実行に問題がある場合は手動でこのツアーをインストールして実行できます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ego get github.com/atotto/go-tour-jp/gotour\ngotour\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    gotour ではローカルバージョンの tour を表示するウェブブラウザが開きます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    もちろん、ここのウェブサイトでGo Tourを続けてもらって構いません。\n  \u003c/p\u003e\n  \n\n","Files":[]},{"Title":"The Go Playground","Content":"\n  \u003ch2\u003eThe Go Playground\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go Tour は、 \u003ca href=\"https://golang.org/\" target=\"_blank\"\u003egolang.org\u003c/a\u003e のサーバで稼働しているウェブサービスの\n\n\n    \u003ca href=\"https://play.golang.org/\" target=\"_blank\"\u003eGo Playground\u003c/a\u003e を利用しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    このウェブサービスは、Goのコードを受け取ると\u003ca href=\"https://ja.wikipedia.org/wiki/%E3%82%B5%E3%83%B3%E3%83%89%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9_(%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3)\" target=\"_blank\"\u003eサンドボックス\u003c/a\u003e内でコンパイル、リンク、実行し、\n\n\n    実行結果の出力を返します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ただし、 playground で実行できるプログラムには制限があります:\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003eplayground 上はいつも \u0026#34;2009-11-10 23:00:00 UTC\u0026#34; (この値の意味は、読者の楽しみのために残しておきます(^^))です。これにより、同じ出力結果を得ることが容易になります。\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \u003cul\u003e\n  \n    \u003cli\u003e実行時間とCPU、メモリの使用量に制限があり、プログラムは外部のネットワークホストへアクセス出来ません。\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    playgroundは、最新の安定バージョンのGoを利用します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    詳細は、 \u0026#34;\u003ca href=\"https://blog.golang.org/playground\" target=\"_blank\"\u003eInside the Go Playground\u003c/a\u003e\u0026#34; を読んでみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"sandbox.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Welcome to the playground!\")\n\n\tfmt.Println(\"The time is\", time.Now())\n}\n","Hash":"bOpKtZ8cTKG+qhINnOZDcJhhNQc="}]},{"Title":"Congratulations","Content":"\n  \u003ch2\u003eCongratulations\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go Tour の最初の章が終わりました。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"javascript:highlightAndClick(\u0026#34;.logo\u0026#34;)\" target=\"_self\"\u003eA Tour of Go をクリック\u003c/a\u003eして学びたいところを見ても良いですし、\n\n\n    直接 \u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e\u0026gt;\u003c/a\u003e をクリックして次の章へ進みましょう。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"basics":{"Title":"Packages, variables, and functions.","Description":"Go プログラムの基本的なコンポーネントを学びます。","Pages":[{"Title":"Packages","Content":"\n  \u003ch2\u003ePackages\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goのプログラムは、パッケージ( \u003ci\u003epackage\u003c/i\u003e )で構成されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    プログラムは \u003ccode\u003emain\u003c/code\u003e パッケージから開始されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    このプログラムでは \u003ccode\u003e\u0026#34;fmt\u0026#34;\u003c/code\u003e と \u003ccode\u003e\u0026#34;math/rand\u0026#34;\u003c/code\u003e パッケージをインポート( \u003ci\u003eimport\u003c/i\u003e )しています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    規約で、パッケージ名はインポートパスの最後の要素と同じ名前になります。\n\n\n    例えば、インポートパスが \u003ccode\u003e\u0026#34;math/rand\u0026#34;\u003c/code\u003e のパッケージは、 \u003ccode\u003epackage rand\u003c/code\u003e ステートメントで始まるファイル群で構成します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003eNote:\u003c/b\u003e ここで実行するプログラムは常に同じ環境で実行されます\n\n\n    ので、\u003ca href=\"http://ja.wikipedia.org/wiki/%E6%93%AC%E4%BC%BC%E4%B9%B1%E6%95%B0\" target=\"_blank\"\u003e擬似乱数\u003c/a\u003eを返す \u003ca href=\"https://golang.org/pkg/math/rand/#Rand.Intn\" target=\"_blank\"\u003e\u003ccode\u003erand.Intn\u003c/code\u003e\u003c/a\u003e はいつも同じ数を返します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (数を強制的に変える場合は、乱数生成でシードを与える必要があります。\u003ca href=\"https://golang.org/pkg/math/rand/#Seed\" target=\"_blank\"\u003e\u003ccode\u003erand.Seed\u003c/code\u003e\u003c/a\u003eを見てみてください。\n\n\n    playground 上での時間は一定なので他のものをシードとして使う必要があります。)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"packages.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc main() {\n\tfmt.Println(\"My favorite number is\", rand.Intn(10))\n}\n","Hash":"3pUhjlSXGcPdkYyhESbolPagQdc="}]},{"Title":"Imports","Content":"\n  \u003ch2\u003eImports\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    このコードでは、括弧でパッケージのインポートをグループ化し、factoredインポートステートメント( \u003ci\u003efactored import statement\u003c/i\u003e )としています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    もちろん、複数のインポートステートメントで書くこともできます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;math\u0026#34;\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    ですが、先に示したfactoredインポートステートメントの方がより良いスタイルです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    訳注: ここの \u003ci\u003efactored\u003c/i\u003e の意味は、「要素化、グループ化、整理済み」ということです。良い日本語募集中。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"imports.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Printf(\"Now you have %g problems.\\n\", math.Sqrt(7))\n}\n","Hash":"lPR2lIWDxWwgjpowRHDjGX2RrHo="}]},{"Title":"Exported names","Content":"\n  \u003ch2\u003eExported names\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goでは、最初の文字が大文字で始まる名前は、外部のパッケージから参照できるエクスポート（公開）された名前( \u003ci\u003eexported name\u003c/i\u003e )です。\n\n\n    例えば、 \u003ccode\u003ePi\u003c/code\u003e は \u003ccode\u003emath\u003c/code\u003e パッケージでエクスポートされています。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    小文字ではじまる \u003ccode\u003epi\u003c/code\u003e や \u003ccode\u003ehoge\u003c/code\u003e などはエクスポートされていない名前です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    パッケージをインポートすると、そのパッケージがエクスポートしている名前を参照することができます。\n\n\n    エクスポートされていない名前(小文字ではじまる名前)は、外部のパッケージからアクセスすることはできません。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    コードを実行し、エラーを確認してみましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    エラーを修正するために、 \u003ccode\u003emath.pi\u003c/code\u003e を \u003ccode\u003emath.Pi\u003c/code\u003e に書き換え、もう一度実行してみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exported-names.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(math.pi)\n}\n","Hash":"8BpBAuTlXDhXXWKPhaWnx31jlc4="}]},{"Title":"Functions","Content":"\n  \u003ch2\u003eFunctions\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数は、0個以上の引数を取ることができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この例では、 \u003ccode\u003eadd\u003c/code\u003e 関数は、 \u003ccode\u003eint\u003c/code\u003e 型の２つのパラメータを取ります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    変数名の \u003cb\u003e後ろ\u003c/b\u003e に型名を書くことに注意してください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    (型をなぜこのように宣言するのか、についての詳細な情報は、 \u003ca href=\"https://blog.golang.org/gos-declaration-syntax\" target=\"_blank\"\u003e記事「Go\u0026#39;s declaration syntax」\u003c/a\u003e を参照してください。)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"functions.go","Content":"package main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n","Hash":"QaLixiSTN/1jtTTP0xgV88EiWbc="}]},{"Title":"Functions continued","Content":"\n  \u003ch2\u003eFunctions continued\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数の２つ以上の引数が同じ型である場合には、最後の型を残して省略して記述できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この例では、\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ex int, y int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    を\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ex, y int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    へ省略できます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"functions-continued.go","Content":"package main\n\nimport \"fmt\"\n\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n","Hash":"qq29LGsGzc3ACpeMJkDSISHbqoM="}]},{"Title":"Multiple results","Content":"\n  \u003ch2\u003eMultiple results\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数は複数の戻り値を返すことができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この \u003ccode\u003eswap\u003c/code\u003e 関数は2つの string を返します。\n\n\n    とても簡単に交換できますね！\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"multiple-results.go","Content":"package main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n","Hash":"VjRC6BmdaRQPFvF3JIg+6vzY0rc="}]},{"Title":"Named return values","Content":"\n  \u003ch2\u003eNamed return values\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Goでの戻り値となる変数に名前をつける( \u003ci\u003enamed return value\u003c/i\u003e )ことができます。戻り値に名前をつけると、関数の最初で定義した変数名として扱われます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    この戻り値の名前は、戻り値の意味を示す名前とすることで、関数のドキュメントとして表現するようにしましょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    名前をつけた戻り値の変数を使うと、 \u003ccode\u003ereturn\u003c/code\u003e ステートメントに何も書かずに戻すことができます。これを \u0026#34;naked\u0026#34; return と呼びます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例のコードのように、naked returnステートメントは、短い関数でのみ利用すべきです。長い関数で使うと読みやすさ( \u003ci\u003ereadability\u003c/i\u003e )に悪影響があります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"named-results.go","Content":"package main\n\nimport \"fmt\"\n\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n","Hash":"AX7YGFmJ2woSa5QTgkprkNt7Ezo="}]},{"Title":"Variables","Content":"\n  \u003ch2\u003eVariables\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003evar\u003c/code\u003e ステートメントは変数( \u003ci\u003evariable\u003c/i\u003e )を宣言します。\n\n\n    関数の引数リストと同様に、複数の変数の最後に型を書くことで、変数のリストを宣言できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003evar\u003c/code\u003e ステートメントはパッケージ、または、関数で利用できます。例のコードで示します。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"variables.go","Content":"package main\n\nimport \"fmt\"\n\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.Println(i, c, python, java)\n}\n","Hash":"IA/svTzSJDH25Jj1VK/auHbrfx0="}]},{"Title":"Variables with initializers","Content":"\n  \u003ch2\u003eVariables with initializers\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003evar\u003c/code\u003e 宣言では、変数毎に初期化子( \u003ci\u003einitializer\u003c/i\u003e )を与えることができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    初期化子が与えられている場合、型を省略できます。その変数は初期化子が持つ型になります。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"variables-with-initializers.go","Content":"package main\n\nimport \"fmt\"\n\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, \"no!\"\n\tfmt.Println(i, j, c, python, java)\n}\n","Hash":"kxySFjAqlylR+dCDsQvw5Ni0k8Q="}]},{"Title":"Short variable declarations","Content":"\n  \u003ch2\u003eShort variable declarations\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    関数の中では、 \u003ccode\u003evar\u003c/code\u003e 宣言の代わりに、短い \u003ccode\u003e:=\u003c/code\u003e の代入文を使い、暗黙的な型宣言ができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    なお、関数の外では、キーワードではじまる宣言( \u003ccode\u003evar\u003c/code\u003e, \u003ccode\u003efunc\u003c/code\u003e, など)が必要で、 \u003ccode\u003e:=\u003c/code\u003e での暗黙的な宣言は利用できません。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"short-variable-declarations.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n\n\tfmt.Println(i, j, k, c, python, java)\n}\n","Hash":"Zz6rkZD1xvZ8Y0U9xTSOJQ3Ec3o="}]},{"Title":"Basic types","Content":"\n  \u003ch2\u003eBasic types\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go言語の基本型(組み込み型)は次のとおりです:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ebool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 の別名\n\nrune // int32 の別名\n     // Unicode のコードポイントを表す\n\nfloat32 float64\n\ncomplex64 complex128\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    (訳注：runeとは古代文字を表す言葉(runes)ですが、Goでは文字そのものを表すためにruneという言葉を使います。)\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例では、いくつかの型の変数を示しています。また、変数宣言は、インポートステートメントと同様に、まとめて( \u003ci\u003efactored\u003c/i\u003e )宣言可能です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003euintptr\u003c/code\u003e 型は、32-bitのシステムでは32 bitで、64-bitのシステムでは64 bitです。\n\n\n    サイズ、符号なし( \u003ci\u003eunsigned\u003c/i\u003e )整数の型を使うための特別な理由がない限り、整数の変数が必要な場合は \u003ccode\u003eint\u003c/code\u003e を使うようにしましょう。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"basic-types.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/cmplx\"\n)\n\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1\u003c\u003c64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tfmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\n\tfmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\n\tfmt.Printf(\"Type: %T Value: %v\\n\", z, z)\n}\n","Hash":"uwd31YbyEsiXFNRjmD+EEctimpc="}]},{"Title":"Zero values","Content":"\n  \u003ch2\u003eZero values\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    変数に初期値を与えずに宣言すると、ゼロ値( \u003ci\u003ezero value\u003c/i\u003e )が与えられます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ゼロ値は型によって以下のように与えられます:\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e数値型(int,floatなど): \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n  \n    \u003cli\u003ebool型: \u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n  \n    \u003cli\u003estring型: \u003ccode\u003e\u0026#34;\u0026#34;\u003c/code\u003e (空文字列( \u003ci\u003eempty string\u003c/i\u003e ))\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"zero.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i int\n\tvar f float64\n\tvar b bool\n\tvar s string\n\tfmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)\n}\n","Hash":"3oy0IiXxtycOjQCkuWLqLa29xzU="}]},{"Title":"Type conversions","Content":"\n  \u003ch2\u003eType conversions\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    型変換\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    変数 \u003ccode\u003ev\u003c/code\u003e 、型 \u003ccode\u003eT\u003c/code\u003e があった場合、 \u003ccode\u003eT(v)\u003c/code\u003e は、変数 \u003ccode\u003ev\u003c/code\u003e を \u003ccode\u003eT\u003c/code\u003e 型へ変換します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    いくつかの変換を見てみましょう:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    よりシンプルに記述できます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei := 42\nf := float64(i)\nu := uint(f)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    C言語とは異なり、Goでの型変換は明示的な変換が必要です。\n\n\n    例のコードで、 \u003ccode\u003efloat64\u003c/code\u003e や \u003ccode\u003euint\u003c/code\u003e の変換を削除し、何が起きるのか確認しましょう。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-conversions.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar x, y int = 3, 4\n\tvar f float64 = math.Sqrt(float64(x*x + y*y))\n\tvar z uint = uint(f)\n\tfmt.Println(x, y, z)\n}\n","Hash":"JGbg9tutd+lDvoRTFMaTExwsKAk="}]},{"Title":"Type inference","Content":"\n  \u003ch2\u003eType inference\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    明示的な型を指定せずに変数を宣言する場合( \u003ccode\u003e:=\u003c/code\u003e や \u003ccode\u003evar =\u003c/code\u003e のいずれか)、変数の型は右側の変数から型推論されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    右側の変数が型を持っている場合、左側の新しい変数は同じ型になります:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar i int\nj := i // j is an int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    右側に型を指定しない数値である場合、左側の新しい変数は右側の定数の精度に基いて \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat64\u003c/code\u003e, \u003ccode\u003ecomplex128\u003c/code\u003e の型になります:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei := 42           // int\nf := 3.142        // float64\ng := 0.867 \u0026#43; 0.5i // complex128\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    例のコードにある変数 \u003ccode\u003ev\u003c/code\u003e の初期値を変えて、型がどのように変化するかを見てみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-inference.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tv := 42 // change me!\n\tfmt.Printf(\"v is of type %T\\n\", v)\n}\n","Hash":"1K7bgjkrtR5wRA38ePeFIDpEEbY="}]},{"Title":"Constants","Content":"\n  \u003ch2\u003eConstants\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    定数( \u003ci\u003econstant\u003c/i\u003e )は、 \u003ccode\u003econst\u003c/code\u003e キーワードを使って変数と同じように宣言します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    定数は、文字(character)、文字列(string)、boolean、数値(numeric)のみで使えます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    なお、定数は \u003ccode\u003e:=\u003c/code\u003e を使って宣言できません。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"constants.go","Content":"package main\n\nimport \"fmt\"\n\nconst Pi = 3.14\n\nfunc main() {\n\tconst World = \"世界\"\n\tfmt.Println(\"Hello\", World)\n\tfmt.Println(\"Happy\", Pi, \"Day\")\n\n\tconst Truth = true\n\tfmt.Println(\"Go rules?\", Truth)\n}\n","Hash":"/KqzBNsqfHiVdOg92MiKtXMexkU="}]},{"Title":"Numeric Constants","Content":"\n  \u003ch2\u003eNumeric Constants\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    数値の定数は、高精度な \u003cb\u003e値\u003c/b\u003e ( \u003ci\u003evalues\u003c/i\u003e )です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    型のない定数は、その状況によって必要な型を取ることになります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例で \u003ccode\u003eneedInt(Big)\u003c/code\u003e も出力してみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ( \u003ccode\u003eint\u003c/code\u003e は最大64-bitの整数を保持できますが、環境によっては精度が低いこともあります)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"numeric-constants.go","Content":"package main\n\nimport \"fmt\"\n\nconst (\n\t// Create a huge number by shifting a 1 bit left 100 places.\n\t// In other words, the binary number that is 1 followed by 100 zeroes.\n\tBig = 1 \u003c\u003c 100\n\t// Shift it right again 99 places, so we end up with 1\u003c\u003c1, or 2.\n\tSmall = Big \u003e\u003e 99\n)\n\nfunc needInt(x int) int { return x*10 + 1 }\nfunc needFloat(x float64) float64 {\n\treturn x * 0.1\n}\n\nfunc main() {\n\tfmt.Println(needInt(Small))\n\tfmt.Println(needFloat(Small))\n\tfmt.Println(needFloat(Big))\n}\n","Hash":"mpa1CTTD2KsjpKwVpbHo9Jz/ujM="}]},{"Title":"Congratulations!","Content":"\n  \u003ch2\u003eCongratulations!\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    この章はこれで終わりです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"/list\" target=\"_self\"\u003e章のリスト\u003c/a\u003eから学びたいところを見ても良いですし、\n\n\n    \u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e\u0026gt;\u003c/a\u003e をクリックして次の章へ進みましょう。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"concurrency":{"Title":"Concurrency","Description":"","Pages":[{"Title":"Goroutines","Content":"\n  \u003ch2\u003eGoroutines\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003cb\u003egoroutine\u003c/b\u003e (ゴルーチン)は、Goのランタイムに管理される軽量なスレッドです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ego f(x, y, z)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    と書けば、新しいgoroutineが実行されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ef(x, y, z)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ef\u003c/code\u003e , \u003ccode\u003ex\u003c/code\u003e , \u003ccode\u003ey\u003c/code\u003e , \u003ccode\u003ez\u003c/code\u003e の評価は、実行元(current)のgoroutineで実行され、 \u003ccode\u003ef\u003c/code\u003e の実行は、新しいgoroutineで実行されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    goroutineは、同じアドレス空間で実行されるため、共有メモリへのアクセスは必ず同期する必要があります。\n\n\n    \u003ca href=\"https://golang.org/pkg/sync/\" target=\"_blank\"\u003e\u003ccode\u003esync\u003c/code\u003e\u003c/a\u003e パッケージは同期する際に役に立つ方法を提供していますが、別の方法があるためそれほど必要ありません。\n\n\n    (次のスライドで説明します)\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"goroutines.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc say(s string) {\n\tfor i := 0; i \u003c 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say(\"world\")\n\tsay(\"hello\")\n}\n","Hash":"V0QWmtbyKtRACHLggPFEhVfjtHk="}]},{"Title":"Channels","Content":"\n  \u003ch2\u003eChannels\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    チャネル( \u003ci\u003eChannel\u003c/i\u003e )型は、チャネルオペレータの \u003ccode\u003e\u0026lt;-\u003c/code\u003e を用いて値の送受信ができる通り道です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ech \u0026lt;- v    // v をチャネル ch へ送信する\nv := \u0026lt;-ch  // ch から受信した変数を v へ割り当てる\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    (データは、矢印の方向に流れます)\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    マップとスライスのように、チャネルは使う前に以下のように生成します:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ech := make(chan int)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    通常、片方が準備できるまで送受信はブロックされます。これにより、明確なロックや条件変数がなくても、goroutineの同期を可能にします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    サンプルコードは、スライス内の数値を合算し、2つのgoroutine間で作業を分配します。\n\n\n    両方のgoroutineで計算が完了すると、最終結果が計算されます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"channels.go","Content":"package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc \u003c- sum // send sum to c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := \u003c-c, \u003c-c // receive from c\n\n\tfmt.Println(x, y, x+y)\n}\n","Hash":"yAHQ/AWnRNOA7NerKhJ0sXl7Q20="}]},{"Title":"Buffered Channels","Content":"\n  \u003ch2\u003eBuffered Channels\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    チャネルは、 \u003cb\u003eバッファ\u003c/b\u003e ( \u003ci\u003ebuffer\u003c/i\u003e )として使えます。\n\n\n    バッファを持つチャネルを初期化するには、 \u003ccode\u003emake\u003c/code\u003e の２つ目の引数にバッファの長さを与えます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ech := make(chan int, 100)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    バッファが詰まった時は、チャネルへの送信をブロックします。\n\n\n    バッファが空の時には、チャネルの受信をブロックします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    バッファが詰まるようにサンプルコードを変更し、何が起きるのかを見てみてください。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"buffered-channels.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch \u003c- 1\n\tch \u003c- 2\n\tfmt.Println(\u003c-ch)\n\tfmt.Println(\u003c-ch)\n}\n","Hash":"HNpu4gbNWpP4WP/6znFerbBix/U="}]},{"Title":"Range and Close","Content":"\n  \u003ch2\u003eRange and Close\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    送り手は、これ以上の送信する値がないことを示すため、チャネルを \u003ccode\u003eclose\u003c/code\u003e できます。\n\n\n    受け手は、受信の式に2つ目のパラメータを割り当てることで、そのチャネルがcloseされているかどうかを確認できます:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ev, ok := \u0026lt;-ch\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    受信する値がない、かつ、チャネルが閉じているなら、 \u003ccode\u003eok\u003c/code\u003e の変数は、 \u003ccode\u003efalse\u003c/code\u003e になります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ループの \u003ccode\u003efor i := range c\u003c/code\u003e は、チャネルが閉じられるまで、チャネルから値を繰り返し受信し続けます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意:\u003c/b\u003e\n\n\n    送り手のチャネルだけをcloseしてください。受け手はcloseしてはいけません。\n\n\n    もしcloseしたチャネルへ送信すると、パニック( \u003ci\u003epanic\u003c/i\u003e )します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003eもう一つ注意:\u003c/b\u003e\n\n\n    チャネルは、ファイルとは異なり、通常は、closeする必要はありません。\n\n\n    closeするのは、これ以上値が来ないことを受け手が知る必要があるときにだけです。\n\n\n    例えば、 \u003ccode\u003erange\u003c/code\u003e ループを終了するという場合です。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"range-and-close.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i \u003c n; i++ {\n\t\tc \u003c- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n","Hash":"4FtqldYWvLh1vO6HNWvr/RcwgBk="}]},{"Title":"Select","Content":"\n  \u003ch2\u003eSelect\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eselect\u003c/code\u003e ステートメントは、goroutineを複数の通信操作で待たせます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eselect\u003c/code\u003e は、複数ある \u003ccode\u003ecase\u003c/code\u003e のいずれかが準備できるようになるまでブロックし、準備ができた \u003ccode\u003ecase\u003c/code\u003e を実行します。\n\n\n    もし、複数の \u003ccode\u003ecase\u003c/code\u003e の準備ができている場合、 \u003ccode\u003ecase\u003c/code\u003e はランダムに選択されます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"select.go","Content":"package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c \u003c- x:\n\t\t\tx, y = y, x+y\n\t\tcase \u003c-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\tfmt.Println(\u003c-c)\n\t\t}\n\t\tquit \u003c- 0\n\t}()\n\tfibonacci(c, quit)\n}\n","Hash":"fsgO6l9yS4Jib1uMTvh+1giFpfg="}]},{"Title":"Default Selection","Content":"\n  \u003ch2\u003eDefault Selection\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    どの \u003ccode\u003ecase\u003c/code\u003e も準備ができていないのであれば、 \u003ccode\u003eselect\u003c/code\u003e の中の \u003ccode\u003edefault\u003c/code\u003e が実行されます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    ブロックせずに送受信するなら、 \u003ccode\u003edefault\u003c/code\u003e の \u003ccode\u003ecase\u003c/code\u003e を使ってください:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eselect {\ncase i := \u0026lt;-c:\n    // use i\ndefault:\n    // receiving from c would block\n}\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"default-selection.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase \u003c-tick:\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase \u003c-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n","Hash":"13nYcML2cEMSMR4KdD858o88aTY="}]},{"Title":"Exercise: Equivalent Binary Trees","Content":"\n  \u003ch2\u003eExercise: Equivalent Binary Trees\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    同じ数列を保持するような、形の異なる\u003ca href=\"https://ja.wikipedia.org/wiki/二分木\" target=\"_blank\"\u003e二分木( \u003ci\u003ebinary tree\u003c/i\u003e )\u003c/a\u003eは多く存在し得ます。\n\n\n    例えば、ここに数列 1, 1, 2, 3, 5, 8, 13 を保持する2つの二分木があります。\n  \u003c/p\u003e\n  \n\n  \u003cimg src=\"/content/img/tree.png\"\u003e\n\n  \n  \u003cp\u003e\n    2つの二分木が同じ数列を保持しているかどうかを確認する機能は、多くの言語においてかなり複雑です。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    シンプルな解決方法を記述するために、Goの並行性( \u003ci\u003econcurrency\u003c/i\u003e )とチャネルを利用してみます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例では、型を以下のように定義している \u003ccode\u003etree\u003c/code\u003e パッケージを利用します:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype Tree struct {\n    Left  *Tree\n    Value int\n    Right *Tree\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e続く...\u003c/a\u003e\n  \u003c/p\u003e\n  \n\n","Files":[]},{"Title":"Exercise: Equivalent Binary Trees","Content":"\n  \u003ch2\u003eExercise: Equivalent Binary Trees\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003cb\u003e1.\u003c/b\u003e  \u003ccode\u003eWalk\u003c/code\u003e 関数を実装してください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e2.\u003c/b\u003e \u003ccode\u003eWalk\u003c/code\u003e 関数をテストしてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    関数 \u003ccode\u003etree.New(k)\u003c/code\u003e は、値( \u003ccode\u003ek\u003c/code\u003e, \u003ccode\u003e2k\u003c/code\u003e, \u003ccode\u003e3k\u003c/code\u003e, ..., \u003ccode\u003e10k\u003c/code\u003e )をもつ、ランダムに構造化 (しかし常にソートされています) した二分木を生成します。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    新しいチャネル \u003ccode\u003ech\u003c/code\u003e を生成し、 \u003ccode\u003eWalk\u003c/code\u003e を動かしましょう:\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ego Walk(tree.New(1), ch)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    そして、そのチャネルから値を読み出し、10個の値を表示してください。\n\n\n    それは、 1, 2, 3, ..., 10 という表示になるでしょう。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e3.\u003c/b\u003e \u003ccode\u003eSame\u003c/code\u003e 関数を実装してください。 \u003ccode\u003et1\u003c/code\u003e と \u003ccode\u003et2\u003c/code\u003e が同じ値を保存しているどうかを判断するため、 \u003ccode\u003eWalk\u003c/code\u003e を使ってください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e4.\u003c/b\u003e  \u003ccode\u003eSame\u003c/code\u003e 関数をテストしてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eSame(tree.New(1), tree.New(1))\u003c/code\u003e は、 \u003ccode\u003etrue\u003c/code\u003e を返すように、\n\n\n    \u003ccode\u003eSame(tree.New(1), tree.New(2))\u003c/code\u003e は、 \u003ccode\u003efalse\u003c/code\u003e を返すようにします。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eTree\u003c/code\u003e のドキュメントは \u003ca href=\"https://godoc.org/golang.org/x/tour/tree#Tree\" target=\"_blank\"\u003eこちら\u003c/a\u003e です。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-equivalent-binary-trees.go","Content":"package main\n\nimport \"golang.org/x/tour/tree\"\n\n// Walk walks the tree t sending all values\n// from the tree to the channel ch.\nfunc Walk(t *tree.Tree, ch chan int)\n\n// Same determines whether the trees\n// t1 and t2 contain the same values.\nfunc Same(t1, t2 *tree.Tree) bool\n\nfunc main() {\n}\n","Hash":"i2l8WC/EscB3twaI/V1sBdoyyRM="}]},{"Title":"sync.Mutex","Content":"\n  \u003ch2\u003esync.Mutex\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    チャネルが、goroutine間で通信するための素晴らしい方法であることを見てきました。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    しかし、通信が必要ない場合はどうでしょう？\n\n\n    コンフリクトを避けるために、一度に1つのgoroutineだけが変数にアクセスできるようにしたい場合はどうでしょうか？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    このコンセプトは、\u003ca href=\"https://ja.wikipedia.org/wiki/%E6%8E%92%E4%BB%96%E5%88%B6%E5%BE%A1\" target=\"_blank\"\u003e排他制御( \u003ci\u003emutual exclusion\u003c/i\u003e )\u003c/a\u003eと呼ばれ、このデータ構造を指す一般的な名前は \u003ca href=\"https://ja.wikipedia.org/wiki/%E3%83%9F%E3%83%A5%E3%83%BC%E3%83%86%E3%83%83%E3%82%AF%E3%82%B9\" target=\"_blank\"\u003e \u003cb\u003emutex\u003c/b\u003e (ミューテックス)\u003c/a\u003eです。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Goの標準ライブラリは、排他制御を\u003ca href=\"https://golang.org/pkg/sync/#Mutex\" target=\"_blank\"\u003e\u003ccode\u003esync.Mutex\u003c/code\u003e\u003c/a\u003eと次の二つのメソッドで提供します:\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e\u003ccode\u003eLock\u003c/code\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ccode\u003eUnlock\u003c/code\u003e\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    \u003ccode\u003eInc\u003c/code\u003e メソッドにあるように、 \u003ccode\u003eLock\u003c/code\u003e と \u003ccode\u003eUnlock\u003c/code\u003e で囲むことで排他制御で実行するコードを定義できます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eValue\u003c/code\u003e メソッドのように、mutexがUnlockされることを保証するために \u003ccode\u003edefer\u003c/code\u003e を使うこともできます。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"mutex-counter.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// SafeCounter is safe to use concurrently.\ntype SafeCounter struct {\n\tmu sync.Mutex\n\tv  map[string]int\n}\n\n// Inc increments the counter for the given key.\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mu.Lock()\n\t// Lock so only one goroutine at a time can access the map c.v.\n\tc.v[key]++\n\tc.mu.Unlock()\n}\n\n// Value returns the current value of the counter for the given key.\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mu.Lock()\n\t// Lock so only one goroutine at a time can access the map c.v.\n\tdefer c.mu.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tgo c.Inc(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n","Hash":"gr5LuYzvEKKTXYO1vTn2QMlF5uQ="}]},{"Title":"Exercise: Web Crawler","Content":"\n  \u003ch2\u003eExercise: Web Crawler\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    この演習では、ウェブクローラ( \u003ci\u003eweb crawler\u003c/i\u003e )を並列化するため、Goの並行性の特徴を使います。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    同じURLを2度取ってくることなく並列してURLを取ってくるように、 \u003ccode\u003eCrawl\u003c/code\u003e 関数を修正してみてください(注1)。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e補足\u003c/b\u003e: 工夫すれば \u003ccode\u003eCrawl\u003c/code\u003e 関数のみの修正で実装できますが、無理に \u003ccode\u003eCrawl\u003c/code\u003e 関数内部に収める必要はありません。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003eひとこと\u003c/b\u003e: mapにフェッチしたURLのキャッシュを保持できますが、mapだけでは並行実行時の安全性はありません!\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-web-crawler.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Fetcher interface {\n\t// Fetch returns the body of URL and\n\t// a slice of URLs found on that page.\n\tFetch(url string) (body string, urls []string, err error)\n}\n\n// Crawl uses fetcher to recursively crawl\n// pages starting with url, to a maximum of depth.\nfunc Crawl(url string, depth int, fetcher Fetcher) {\n\t// TODO: Fetch URLs in parallel.\n\t// TODO: Don't fetch the same URL twice.\n\t// This implementation doesn't do either:\n\tif depth \u003c= 0 {\n\t\treturn\n\t}\n\tbody, urls, err := fetcher.Fetch(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Printf(\"found: %s %q\\n\", url, body)\n\tfor _, u := range urls {\n\t\tCrawl(u, depth-1, fetcher)\n\t}\n\treturn\n}\n\nfunc main() {\n\tCrawl(\"https://golang.org/\", 4, fetcher)\n}\n\n// fakeFetcher is Fetcher that returns canned results.\ntype fakeFetcher map[string]*fakeResult\n\ntype fakeResult struct {\n\tbody string\n\turls []string\n}\n\nfunc (f fakeFetcher) Fetch(url string) (string, []string, error) {\n\tif res, ok := f[url]; ok {\n\t\treturn res.body, res.urls, nil\n\t}\n\treturn \"\", nil, fmt.Errorf(\"not found: %s\", url)\n}\n\n// fetcher is a populated fakeFetcher.\nvar fetcher = fakeFetcher{\n\t\"https://golang.org/\": \u0026fakeResult{\n\t\t\"The Go Programming Language\",\n\t\t[]string{\n\t\t\t\"https://golang.org/pkg/\",\n\t\t\t\"https://golang.org/cmd/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/\": \u0026fakeResult{\n\t\t\"Packages\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/cmd/\",\n\t\t\t\"https://golang.org/pkg/fmt/\",\n\t\t\t\"https://golang.org/pkg/os/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/fmt/\": \u0026fakeResult{\n\t\t\"Package fmt\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/pkg/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/os/\": \u0026fakeResult{\n\t\t\"Package os\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/pkg/\",\n\t\t},\n\t},\n}\n","Hash":"B/FADMZ6HBiJeHh8jLlvxCXPbew="}]},{"Title":"Where to Go from here...","Content":"\n  \u003ch2\u003eWhere to Go from here...\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ca href=\"https://golang.org/dl/\" target=\"_blank\"\u003eGoをインストール\u003c/a\u003e\n\n\n    することで、Go言語を始めることができます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Goをインストールしたなら、\n\n\n    \u003ca href=\"https://golang.org/doc/\" target=\"_blank\"\u003eGoのドキュメント\u003c/a\u003e は、\n\n\n    次に参考にする\n\n\n    にはとても良いものです。\n\n\n    ここにはリファレンスやチュートリアル、ビデオなどがあります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Goのコードの構成や、動かし方を学ぶためには、 \u003ca href=\"https://www.youtube.com/watch?v=XCsL89YtqCs\" target=\"_blank\"\u003eこの動画\u003c/a\u003e を見てください。また、 \u003ca href=\"https://golang.org/doc/code.html\" target=\"_blank\"\u003eHow to Write Go Code\u003c/a\u003e を読んでください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    もし、標準ライブラリに関してヘルプが必要なら、\n\n\n    \u003ca href=\"https://golang.org/pkg/\" target=\"_blank\"\u003eパッケージリファレンス\u003c/a\u003e\n\n\n    を見てください。\n\n\n    言語自身に関してのヘルプは、\n\n\n    \u003ca href=\"https://golang.org/ref/spec\" target=\"_blank\"\u003eGo言語仕様\u003c/a\u003e\n\n\n    がとても参考になります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Goの並行性のモデルについてもっと調べてみたいなら、\n\n\n    \u003ca href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\" target=\"_blank\"\u003eGo Concurrency Patterns\u003c/a\u003e\n\n\n    (\u003ca href=\"https://talks.golang.org/2012/concurrency.slide\" target=\"_blank\"\u003eslides\u003c/a\u003e)\n\n\n    や、\n\n\n    \u003ca href=\"https://www.youtube.com/watch?v=QDDwwePbDtw\" target=\"_blank\"\u003eAdvanced Go Concurrency Patterns\u003c/a\u003e\n\n\n    (\u003ca href=\"https://talks.golang.org/2013/advconc.slide\" target=\"_blank\"\u003eslides\u003c/a\u003e)\n\n\n    を見たり、\n\n\n    codewalk:\n\n\n    \u003ca href=\"https://golang.org/doc/codewalk/sharemem/\" target=\"_blank\"\u003eShare Memory by Communicating\u003c/a\u003e\n\n\n    を読んでみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Webアプリケーションをはじめてみるなら、\n\n\n    \u003ca href=\"https://vimeo.com/53221558\" target=\"_blank\"\u003eA simple programming environment\u003c/a\u003e\n\n\n    (\u003ca href=\"https://talks.golang.org/2012/simple.slide\" target=\"_blank\"\u003eslides\u003c/a\u003e)\n\n\n    を見たり、\n\n\n    チュートリアル:\n\n\n    \u003ca href=\"https://golang.org/doc/articles/wiki/\" target=\"_blank\"\u003eWriting Web Applications\u003c/a\u003e\n\n\n    を読んでみてください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"https://golang.org/doc/codewalk/functions/\" target=\"_blank\"\u003eFirst Class Functions in Go\u003c/a\u003e\n\n\n    では、Goの関数型の興味深い側面を教えてくれます。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"https://blog.golang.org/\" target=\"_blank\"\u003eGo Blog\u003c/a\u003e\n\n\n    には、Goに関する素晴らしい記事の多くのアーカイブがあります。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    もちろん、 \u003ca href=\"https://golang.org\" target=\"_blank\"\u003egolang.org\u003c/a\u003e\n\n\n    も見てください。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ci\u003e翻訳：\u003c/i\u003e \u003ca href=\"https://github.com/atotto/go-tour-jp\" target=\"_blank\"\u003e\u003ci\u003e@atotto\u003c/i\u003e\u003c/a\u003e\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
}